if game.PlaceId == 121864768012064 then ---ikan
local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/danuup16/mnbru/refs/heads/main/mnu"))()
local HttpService = game:GetService("HttpService")
local AutoConfig = {} do
    AutoConfig.FolderName = "DJSTest"
    AutoConfig.ConfigFile = "DJSikan.json"
    AutoConfig.Library = nil
    AutoConfig.LastSaveTime = 0
    AutoConfig.IsMonitoring = false
    AutoConfig.Parsers = {
        Toggle = {
            Save = function(idx, option) 
                return { type = "Toggle", idx = idx, value = option.Value } 
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, option)
                return { type = "Slider", idx = idx, value = tonumber(option.Value) }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, option)
                return { type = "Dropdown", idx = idx, value = option.Value, multi = option.Multi }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Colorpicker = {
            Save = function(idx, option)
                return { type = "Colorpicker", idx = idx, value = option.Value:ToHex(), transparency = option.Transparency }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
                end
            end,
        },
        Input = {
            Save = function(idx, option)
                return { type = "Input", idx = idx, text = option.Value }
            end,
            Load = function(idx, data, options)
                if options[idx] and type(data.text) == "string" then
                    options[idx]:SetValue(data.text)
                end
            end,
        },
    }
    
    function AutoConfig:Initialize(library)
        self.Library = library
        self:CreateFolders()
        wait(2) 
        self:LoadConfig()
        self:StartChangeMonitoring()
    end
    
    function AutoConfig:CreateFolders()
        if not isfolder(self.FolderName) then
            makefolder(self.FolderName)
        end
    end
    
    function AutoConfig:GetFilePath()
        return self.FolderName .. "/" .. self.ConfigFile
    end
    
    function AutoConfig:SaveConfig()
        local data = { objects = {} }
        
        for idx, option in pairs(self.Library.Options) do
            local parser = self.Parsers[option.Type]
            if parser then
                table.insert(data.objects, parser.Save(idx, option))
            end
        end
        
        local success, encoded = pcall(HttpService.JSONEncode, HttpService, data)
        if success then
            writefile(self:GetFilePath(), encoded)
            self.LastSaveTime = tick()
            return true, "Config saved successfully"
        else
            return false, "Failed to encode config data"
        end
    end
    
    function AutoConfig:LoadConfig()
        local filePath = self:GetFilePath()
        
        if not isfile(filePath) then
            return false, "No config file found"
        end
        
        local success, decoded = pcall(HttpService.JSONDecode, HttpService, readfile(filePath))
        if not success then
            return false, "Failed to decode config"
        end
        
        for _, item in pairs(decoded.objects) do
            local parser = self.Parsers[item.type]
            if parser then
                spawn(function()
                    parser.Load(item.idx, item, self.Library.Options)
                end)
            end
        end
        return true, "Config loaded successfully"
    end
    function AutoConfig:StartChangeMonitoring()
        if self.IsMonitoring then return end
        self.IsMonitoring = true
        local lastValues = {}
        for idx, option in pairs(self.Library.Options) do
            lastValues[idx] = self:GetOptionValue(option)
        end
        
        spawn(function()
            while self.IsMonitoring do
                wait(0.5)
                
                local hasChanges = false
                for idx, option in pairs(self.Library.Options) do
                    local currentValue = self:GetOptionValue(option)
                    if self:ValuesAreDifferent(lastValues[idx], currentValue) then
                        lastValues[idx] = currentValue
                        hasChanges = true
                    end
                end
                
                if hasChanges then
                    local success, msg = self:SaveConfig()
                end
            end
        end)
    end
    function AutoConfig:GetOptionValue(option)
        if option.Type == "Toggle" then
            return option.Value
        elseif option.Type == "Slider" then
            return option.Value
        elseif option.Type == "Dropdown" then
            return option.Value
        elseif option.Type == "Input" then
            return option.Value
        elseif option.Type == "Colorpicker" then
            return {option.Value:ToHex(), option.Transparency}
        end
        return nil
    end
    function AutoConfig:ValuesAreDifferent(oldValue, newValue)
        if type(oldValue) ~= type(newValue) then
            return true
        end
        if type(oldValue) == "table" then
            if #oldValue ~= #newValue then return true end
            for i = 1, #oldValue do
                if oldValue[i] ~= newValue[i] then return true end
            end
            return false
        end
        
        return oldValue ~= newValue
    end
    function AutoConfig:StopMonitoring()
        self.IsMonitoring = false
    end
    
    function AutoConfig:ManualSave()
        return self:SaveConfig()
    end
    
    function AutoConfig:GetLastSaveTime()
        return self.LastSaveTime
    end
end
local Window = Fluent:CreateWindow({
    Title = "#DJSTEST - FISH IT V.10",
    SubTitle = "  https://discord.gg/uwXYuxj6cF",
    TabWidth = 160,
    Size = UDim2.fromOffset(650, 400),
    Transparency = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.F
})
local Tabs = {
    Info = Window:AddTab({ Title = "Info Script", Icon = "info" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user-cog" }),
    Fishing = Window:AddTab({ Title = "Fishing", Icon = "anchor" }),
    Inventory = Window:AddTab({ Title = "Inventory", Icon = "backpack" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "map-pin" }),
    Buy = Window:AddTab({ Title = "Buy", Icon = "shopping-cart" }),
    Webhook = Window:AddTab({ Title = "Webhook", Icon = "bell-ring" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}
local Options = Fluent.Options
local defaultWalkSpeed = 16
local defaultJumpPower = 16
local isWalkSpeedActive = false
local currentWalkSpeed = 50
local function setupCharacter()
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if not Options.WalkSpeedSlider then
            defaultWalkSpeed = humanoid.WalkSpeed
        end
        if not Options.JumpHeightSlider then
            defaultJumpPower = humanoid.JumpPower
        end
        
        -- Apply walk speed based on toggle state
        if isWalkSpeedActive and Options.WalkSpeedSlider then
            humanoid.WalkSpeed = Options.WalkSpeedSlider.Value or currentWalkSpeed
        else
            humanoid.WalkSpeed = defaultWalkSpeed
        end
        
        if Options.JumpHeightSlider then
            humanoid.JumpPower = Options.JumpHeightSlider.Value or defaultJumpPower
        end
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacter)
if game.Players.LocalPlayer.Character then
    setupCharacter()
end
do
    Tabs.Info:AddButton({
        Title = "Discord Server",
        Description = "Discord invite link",
        Callback = function()
            setclipboard("https://discord.gg/uwXYuxj6cF")
        end
    })
    
    Tabs.Info:AddButton({
        Title = "Tiktok",
        Description = "Tiktok profile link",
        Callback = function()
            setclipboard("https://www.tiktok.com/@sjunaadd")
        end
    })
end
do
    local WalkSpeedSlider = Tabs.Player:AddSlider("WalkSpeedSlider", {
        Title = "Walk Speed",
        Description = "Control your walking speed",
        Default = 50,
        Min = 16,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            currentWalkSpeed = Value
            -- Only apply if toggle is active
            if isWalkSpeedActive then
                local player = game.Players.LocalPlayer
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.WalkSpeed = Value
                end
            end
        end
    })
    
    -- Jump Height
    local JumpHeightSlider = Tabs.Player:AddSlider("JumpHeightSlider", {
        Title = "Jump Height",
        Description = "Control your jumping power",
        Default = defaultJumpPower,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid.JumpPower = Value
            end
        end
    })
    
    -- Fly variables and functions
    local flyBodyVelocity = nil
    local flyBodyPosition = nil
    local isFlyActive = false
    local flySpeed = 50
    
    local FlySpeedSlider = Tabs.Player:AddSlider("FlySpeedSlider", {
        Title = "Fly Speed",
        Description = "Control your flying speed",
        Default = flySpeed,
        Min = 10,
        Max = 1000,
        Rounding = 5,
        Callback = function(Value)
            flySpeed = Value
        end
    })
    
    local function enableFly()
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return false
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        flyBodyVelocity.Parent = humanoidRootPart
        flyBodyPosition = Instance.new("BodyPosition")
        flyBodyPosition.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyPosition.Position = humanoidRootPart.Position
        flyBodyPosition.Parent = humanoidRootPart
        return true
    end
    
    local function disableFly()
        if flyBodyVelocity then
            flyBodyVelocity:Destroy()
            flyBodyVelocity = nil
        end
        if flyBodyPosition then
            flyBodyPosition:Destroy()
            flyBodyPosition = nil
        end
    end
    
    local function updateFlyMovement()
        local player = game.Players.LocalPlayer
        local camera = workspace.CurrentCamera
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not flyBodyVelocity or not flyBodyPosition or not humanoid then
            return
        end
        local moveVector = humanoid.MoveDirection
        local velocity = Vector3.new(0, 0, 0)
        if moveVector.Magnitude > 0 then
            local cameraDirection = camera.CFrame.LookVector
            local flatDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).Unit
            velocity = flatDirection * moveVector.Magnitude * flySpeed
        end
        local userInputService = game:GetService("UserInputService")
        if userInputService:IsKeyDown(Enum.KeyCode.Space) then
            velocity = velocity + Vector3.new(0, flySpeed, 0)
        end
        if userInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            velocity = velocity + Vector3.new(0, -flySpeed, 0)
        end
        flyBodyVelocity.Velocity = velocity
        if velocity.Magnitude == 0 then
            flyBodyPosition.Position = humanoidRootPart.Position
        else
            flyBodyPosition.Position = humanoidRootPart.Position + velocity * 0.1
        end
    end
     -- Walk Speed Toggle
    local WalkSpeedToggle = Tabs.Player:AddToggle("WalkSpeedToggle", {
        Title = "Walk Speed",
        Description = "Enable custom walk speed",
        Default = false,
        Callback = function(Value)
            isWalkSpeedActive = Value
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                if Value then
                    player.Character.Humanoid.WalkSpeed = currentWalkSpeed
                else
                    player.Character.Humanoid.WalkSpeed = defaultWalkSpeed
                end
            end
        end
    })
    local flyToggle = Tabs.Player:AddToggle("FlyToggle", {
        Title = "Fly",
        Description = "Enable flying mode",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isFlyActive then
                    if enableFly() then
                        isFlyActive = true
                        spawn(function()
                            while isFlyActive do
                                updateFlyMovement()
                                game:GetService("RunService").Heartbeat:Wait()
                            end
                        end)
                    end
                end
            else
                if isFlyActive then
                    isFlyActive = false
                    disableFly()
                end
            end
        end
    })
    
    -- Infinite Jump
    local infiniteJumpConnection = nil
    local isInfiniteJumpActive = false
    
    local function enableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
        end
        infiniteJumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    end
    
    local function disableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
            infiniteJumpConnection = nil
        end
    end
    
    local infiniteJump = Tabs.Player:AddToggle("InfiniteJump", {
        Title = "Infinite Jump",
        Description = "Jump infinitely without touching ground",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isInfiniteJumpActive then
                    enableInfiniteJump()
                    isInfiniteJumpActive = true
                end
            else
                if isInfiniteJumpActive then
                    disableInfiniteJump()
                    isInfiniteJumpActive = false
                end
            end
        end
    })
    
    -- No Clip
    local isNoclipActive = false
    local noclipConnection = nil
    local RunService = game:GetService("RunService")
    
    local function enableNoclip()
        local player = game.Players.LocalPlayer
        if not player.Character then
            return false
        end
        if noclipConnection then
            noclipConnection:Disconnect()
        end
        noclipConnection = RunService.Stepped:Connect(function()
            if not isNoclipActive then
                noclipConnection:Disconnect()
                return
            end
            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
        
        return true
    end
    
    local function disableNoclip()
        local player = game.Players.LocalPlayer
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    if part.Name == "Head" or part.Name:find("Torso") or part.Name:find("Arm") or part.Name:find("Leg") then
                        part.CanCollide = false
                    else
                        part.CanCollide = true
                    end
                end
            end
            if player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CanCollide = false
            end
        end
    end
    
    local function setupCharacterNoclip()
        local player = game.Players.LocalPlayer
        if player.Character and isNoclipActive then
            wait(0.5)
            enableNoclip()
        end
    end
    
    game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacterNoclip)
    
    local noclipToggle = Tabs.Player:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(Value)
            isNoclipActive = Value
            if Value then
                enableNoclip()
            else
                disableNoclip()
            end
        end
    })
    
    -- Anti AFK
    local antiAfkConnection = nil
    local isAntiAfkActive = false
    
    local antiAfkToggle = Tabs.Player:AddToggle("AntiAfk", {
        Title = "Anti AFK",
        Description = "Prevent getting kicked for being idle",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isAntiAfkActive then
                    local VirtualUser = game:GetService('VirtualUser')
                    antiAfkConnection = game:GetService('Players').LocalPlayer.Idled:Connect(function()
                        VirtualUser:CaptureController()
                        VirtualUser:ClickButton2(Vector2.new())
                    end)
                    isAntiAfkActive = true
                end
            else
                if antiAfkConnection and isAntiAfkActive then
                    antiAfkConnection:Disconnect()
                    antiAfkConnection = nil
                    isAntiAfkActive = false
                end
            end
        end
    })
end
do
local isAutoFishActive = false
local fishingDelay = 2.3 
local isAutoPerfectActive = false
local isAutoAmazingActive = false
local toolRefreshInterval = 300
local lastToolRefreshTime = 0

-- V2 Variables with respawn protection
local isAutoFishV2Active = false
local fishingV2DelayTime = 0
local fishingControllerModule = nil
local lastToolRefreshTimeV2 = 0
local toolRefreshIntervalV2 = 300
local autoFishV2Thread = nil -- Track main thread
local characterConnection = nil -- Track character respawn

-- Global variables untuk instant restart system
local fishingCompletionConnection = nil
local isWaitingForCompletion = false

local function equipFishingTool()
   local success, error = pcall(function()
      local ReplicatedStorage = game:GetService("ReplicatedStorage")
      local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
      if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return false
      end
      local net = netFolder.net
      local equipTool = net:FindFirstChild("RE/EquipToolFromHotbar")
      if equipTool then
         equipTool:FireServer(1)
         return true
      end
      return false
   end)
   if not success then
      warn("Equip tool error: " .. tostring(error))
      return false
   end
   return success
end

local function unequipFishingTool()
   local success, error = pcall(function()
      local ReplicatedStorage = game:GetService("ReplicatedStorage")
      local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
      if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return false
      end
      local net = netFolder.net
      local unequipTool = net:FindFirstChild("RE/UnequipToolFromHotbar")
      if unequipTool then
         unequipTool:FireServer()
         return true
      end
      return false
   end)
   
   if not success then
      warn("Unequip tool error: " .. tostring(error))
      return false
   end
   return success
end

-- Check if player character is valid and alive
local function isPlayerValid()
    local player = game.Players.LocalPlayer
    if not player then return false end
    
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    -- Check if humanoid is alive
    if humanoid.Health <= 0 then return false end
    
    return true
end

local function performFishingCycle()
 local success, error = pcall(function()
     local ReplicatedStorage = game:GetService("ReplicatedStorage")
     local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
     
     if not netFolder or not netFolder:FindFirstChild("net") then
         warn("Network folder not found!")
         return
     end
     local net = netFolder.net
     local chargeFishingRod = net:FindFirstChild("RF/ChargeFishingRod")
     if chargeFishingRod then
         if isAutoPerfectActive then
             local value = 9999999999
             chargeFishingRod:InvokeServer(value)
         elseif isAutoAmazingActive then
             local value = 1755509015.922411
             chargeFishingRod:InvokeServer(value)
         else
             local value = math.random(8000, 10000)
             chargeFishingRod:InvokeServer(value)
         end
         task.wait(0.3)
     end
     local requestFishing = net:FindFirstChild("RF/RequestFishingMinigameStarted")
     if requestFishing then
         if isAutoPerfectActive then
             requestFishing:InvokeServer(0, 1)
         elseif isAutoAmazingActive then
             requestFishing:InvokeServer(-139.6379699707, 0.87694226394928)
         else
             local randomX = math.random(-200, 200) / 100
             local randomY = math.random(50, 100) / 100
             requestFishing:InvokeServer(randomX, randomY)
         end
     end
     task.wait(fishingDelay)
     local fishingCompleted = net:FindFirstChild("RE/FishingCompleted")
     if fishingCompleted then
         fishingCompleted:FireServer()
         task.wait(0.5)
         
         local currentTime = tick()
         if currentTime - lastToolRefreshTime >= toolRefreshInterval then
             lastToolRefreshTime = currentTime
             task.wait(0.5)
         end
     end
 end)
 if not success then
     warn("Fishing cycle error: " .. tostring(error))
 end
end

Tabs.Fishing:AddSection("Auto Fishing V1")
local FishingDelaySlider = Tabs.Fishing:AddSlider("FishingDelay", {
    Title = "Fishing Delay V1",
    Description = "Adjust delay between fishing cycles, Default 2.3",
    Default = 2.3,
    Min = 2.3,
    Max = 10,
    Rounding = 0.1,
    Callback = function(Value)
        fishingDelay = Value
    end
})

local AutoFishingToggle = Tabs.Fishing:AddToggle("AutoFishing", {
   Title = "Auto Fishing V1",
   Description = "Automatically fish",
   Default = false,
   Callback = function(Value)
      if Value then
         if not isAutoFishActive then
            if equipFishingTool() then
               isAutoFishActive = true
               lastToolRefreshTime = tick()
               wait(1) 
               spawn(function()
                  while isAutoFishActive do
                     if not isAutoFishActive then break end 
                     performFishingCycle()
                     for i = 1, 10 do
                        if not isAutoFishActive then break end
                        wait(0.1)
                     end
                  end
               end)
            end
         end
      else
         if isAutoFishActive then
            isAutoFishActive = false 
            spawn(function()
               unequipFishingTool()
            end)
         end
      end
   end,
})

local AutoPerfectToggle = Tabs.Fishing:AddToggle("AutoPerfect", {
 Title = "Auto Perfect",
 Description = "Perfect catch every time",
 Default = false,
 Callback = function(Value)
     isAutoPerfectActive = Value
     if Value then
         isAutoAmazingActive = false
         Options.AutoAmazing:SetValue(false)
     end
 end,
})

local AutoAmazingToggle = Tabs.Fishing:AddToggle("AutoAmazing", {
 Title = "Auto Amazing",
 Description = "Amazing catch every time",
 Default = false,
 Callback = function(Value)
     isAutoAmazingActive = Value
     if Value then
         isAutoPerfectActive = false
         Options.AutoPerfect:SetValue(false)
     end
 end,
})

local SellFishButton = Tabs.Fishing:AddButton({
   Title = "Sell All Fish",
   Description = "Sell all fish in inventory",
   Callback = function()
      local success, error = pcall(function()
         local ReplicatedStorage = game:GetService("ReplicatedStorage")
         local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
         if netFolder and netFolder:FindFirstChild("net") then
            local net = netFolder.net
            local sellAllItems = net:FindFirstChild("RF/SellAllItems")
            if sellAllItems then
               sellAllItems:InvokeServer()
            end
         end
      end)
   end,
})

Tabs.Fishing:AddSection("Auto Fishing V2")
local function resetFishingController()
    fishingControllerModule = nil
end
local function getFishingController()
    if not isPlayerValid() then
        return nil
    end
    local success, result = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
        if Controllers then
            local FishingController = Controllers:FindFirstChild("FishingController")
            if FishingController then
                return require(FishingController)
            end
        end
        return nil
    end)
    
    if success and result then
        fishingControllerModule = result
        return fishingControllerModule
    end
    
    return nil
end
local function ensureFishingToolEquipped()
    if not isPlayerValid() then
        return false
    end
    
    local currentTime = tick()
    if currentTime - lastToolRefreshTimeV2 >= toolRefreshIntervalV2 then
        lastToolRefreshTimeV2 = currentTime
        return equipFishingTool()
    end
    return true
end

-- Function untuk start fishing cycle dengan zero delay
local function startFishingCycleOnly()
    if not isPlayerValid() then
        return false
    end
    
    local success, error = pcall(function()
        if not ensureFishingToolEquipped() then
            warn("[AUTO FISHING V2] Failed to equip tool")
            return false
        end
        
        local controller = getFishingController()
        if not controller then
            warn("[AUTO FISHING V2] Controller not found")
            return false
        end
        
        local camera = workspace.CurrentCamera
        if not camera then
            warn("[AUTO FISHING V2] Camera not found")
            return false
        end
        
        local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        
        -- Langsung start tanpa check cooldown untuk speed maksimal
        -- (cooldown check akan dilakukan oleh controller sendiri)
        controller:RequestChargeFishingRod(screenCenter, true, true)
        isWaitingForCompletion = true -- Set flag bahwa sedang tunggu completion
        
        return true
    end)
    
    if not success then
        warn("[AUTO FISHING V2] Error: " .. tostring(error))
        isWaitingForCompletion = false
        return false
    end
    return success
end

-- Function untuk monitor dan auto-click selama fishing (lebih agresif)
local function monitorFishingProcess()
    spawn(function()
        while isAutoFishV2Active and isWaitingForCompletion do
            if not isPlayerValid() then
                break
            end
            
            local success = pcall(function()
                local controller = getFishingController()
                if controller then
                    local currentGUID = controller:GetCurrentGUID()
                    if currentGUID then
                        -- Click multiple times untuk ensure minigame completion
                        for i = 1, 2 do
                            controller:RequestFishingMinigameClick()
                        end
                    end
                end
            end)
            
            task.wait(0.03) -- Very fast clicking seperti original tapi lebih cepat
        end
    end)
end

-- Function untuk setup completion event listener (dengan safety checks)
local function setupCompletionListener()
    if fishingCompletionConnection then
        fishingCompletionConnection:Disconnect()
    end
    
    -- Monitor network events untuk detect completion
    local RunService = game:GetService("RunService")
    fishingCompletionConnection = RunService.Heartbeat:Connect(function()
        if not isAutoFishV2Active or not isPlayerValid() then
            if fishingCompletionConnection then
                fishingCompletionConnection:Disconnect()
                fishingCompletionConnection = nil
            end
            return
        end
        
        -- Jika sedang menunggu completion
        if isWaitingForCompletion then
            local success = pcall(function()
                local controller = getFishingController()
                if controller then
                    local currentGUID = controller:GetCurrentGUID()
                    if currentGUID then
                        -- Fire completion event
                        local ReplicatedStorage = game:GetService("ReplicatedStorage")
                        local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                        if netFolder and netFolder:FindFirstChild("net") then
                            local net = netFolder.net
                            local fishingCompleted = net:FindFirstChild("RE/FishingCompleted")
                            if fishingCompleted then
                                fishingCompleted:FireServer()
                                
                                -- LANGSUNG START CYCLE BARU!
                                isWaitingForCompletion = false
                                
                                -- Apply user delay jika ada
                                local delayTime = tonumber(fishingV2DelayTime) or 0
                                if delayTime > 0 then
                                    task.wait(delayTime)
                                else
                                    task.wait(0.05) -- Minimal delay untuk server response
                                end
                                
                                -- Start cycle baru immediately
                                if isAutoFishV2Active and isPlayerValid() then
                                    if startFishingCycleOnly() then
                                        monitorFishingProcess()
                                    end
                                end
                            end
                        end
                    else
                        -- Jika tidak ada GUID tapi masih waiting, coba restart setelah delay
                        local waitTime = 0
                        while waitTime < 3 and isWaitingForCompletion and not controller:GetCurrentGUID() do
                           -- task.wait(0.05)
                            waitTime = waitTime + 0.1
                        end
                        
                        -- Jika masih tidak ada GUID, restart cycle
                        if isWaitingForCompletion and not controller:GetCurrentGUID() then
                            isWaitingForCompletion = false
                            if isAutoFishV2Active and isPlayerValid() then
                                if startFishingCycleOnly() then
                                    monitorFishingProcess()
                                end
                            end
                        end
                    end
                end
            end)
        end
    end)
end
local function startAutoFishingV2()
    if not isPlayerValid() then
        warn("[AUTO FISHING V2] Player not valid")
        return false
    end
    
    if not equipFishingTool() then
        warn("[AUTO FISHING V2] Failed to equip tool")
        return false
    end
    
    local controller = getFishingController()
    if not controller then
        warn("[AUTO FISHING V2] Controller not found")
        return false
    end
    local player = game.Players.LocalPlayer
    if characterConnection then
        characterConnection:Disconnect()
    end
    
    characterConnection = player.CharacterRemoving:Connect(function()
        if Options and Options.AutoFishingV2 then
            Options.AutoFishingV2:SetValue(false)
        end
    end)
    setupCompletionListener()
    if startFishingCycleOnly() then
        monitorFishingProcess()
    else
        return false
    end
    
    return true
end
local function stopAutoFishingV2()
    isAutoFishV2Active = false
    isWaitingForCompletion = false
    
    if fishingCompletionConnection then
        fishingCompletionConnection:Disconnect()
        fishingCompletionConnection = nil
    end
    
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end
    
    if autoFishV2Thread then
      --  task.wait(0.5)
        autoFishV2Thread = nil
    end
    
    resetFishingController()
    pcall(function()
        unequipFishingTool()
    end)
end

local autoFishV2Toggle = Tabs.Fishing:AddToggle("AutoFishingV2", {
    Title = "Auto Fishing V2",
    Description = "Instant restart after completion",
    Default = false,
    Callback = function(Value)
        if Value then
            if not isAutoFishV2Active then
                isAutoFishV2Active = true
                if not startAutoFishingV2() then
                    isAutoFishV2Active = false
                    Options.AutoFishingV2:SetValue(false)
                end
            end
        else
            if isAutoFishV2Active then
                stopAutoFishingV2()
            end
        end
    end
})
local fishingV2DelaySlider = Tabs.Fishing:AddSlider("FishingV2Delay", {
    Title = "Fishing Delay V2",
    Description = "Delay between fishing cycles (seconds)",
    Default = 0,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        fishingV2DelayTime = tonumber(Value) or 0
    end
})

-- Auto Click V2 with respawn protection
local isAutoClickV2Active = false
local autoClickV2Thread = nil

local autoClickV2Toggle = Tabs.Fishing:AddToggle("AutoClickV2", {
    Title = "Auto Click",
    Description = "For auto fishing v2",
    Default = false,
    Callback = function(Value)
        isAutoClickV2Active = Value
        if Value then
            autoClickV2Thread = spawn(function()
                while isAutoClickV2Active do
                    if not isPlayerValid() then
                        if Options and Options.AutoClickV2 then
                            Options.AutoClickV2:SetValue(false)
                        end
                        break
                    end
                    
                    local success, error = pcall(function()
                        local controller = getFishingController()
                        if controller then
                            local currentGUID = controller:GetCurrentGUID()
                            if currentGUID then
                                for i = 1, 3 do
                                    controller:RequestFishingMinigameClick()
                                    task.wait(0.05)
                                end
                            end
                        end
                    end)
                    if not success then
                        warn("[AUTO CLICK V2] Error: " .. tostring(error))
                    end
                    task.wait(0.05)
                end
            end)
        else
            if autoClickV2Thread then
                autoClickV2Thread = nil
            end
        end
    end
})

local isInstantReelActive = false
local instantReelConnection = nil

local function startInstantReel()
    if instantReelConnection then
        instantReelConnection:Disconnect()
    end
    
    local RunService = game:GetService("RunService")
    instantReelConnection = RunService.Heartbeat:Connect(function()
        if not isInstantReelActive then
            instantReelConnection:Disconnect()
            return
        end
        
        if not isPlayerValid() then
            if Options and Options.instrail then
                Options.instrail:SetValue(false)
            end
            return
        end
        
        local success, error = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
            if netFolder and netFolder:FindFirstChild("net") then
                local net = netFolder.net
                local fishingCompleted = net:FindFirstChild("RE/FishingCompleted")
                if fishingCompleted then
                    fishingCompleted:FireServer()
                end
            end
        end)
        
        if not success then
            warn("Instant reel error: " .. tostring(error))
        end
    end)
end

local function stopInstantReel()
    if instantReelConnection then
        instantReelConnection:Disconnect()
        instantReelConnection = nil
    end
end

local instantReelToggle = Tabs.Fishing:AddToggle("instrail", {
    Title = "Instant Reel",
    Description = "For auto fishing v2",
    Default = false,
    Callback = function(Value)
        isInstantReelActive = Value
        if Value then
            startInstantReel()
        else
            stopInstantReel()
        end
    end
})

-- Auto Farm V1
Tabs.Fishing:AddSection("Auto Farm V1")
local selectedFarmLocation = nil
local isAutoFarmActive = false
local selectedFarmMethodV1 = "V1"
local farmLocations = {
   ["Kohana"] = CFrame.new(-686.516663, 3.035492, 799.652039, -0.999842, 0.000000, 0.017792, 0.000000, 1.000000, -0.000000, -0.017792, -0.000000, -0.999842),
   ["Kohana Volcano"] = CFrame.new(-634.442505, 56.306618, 203.509964, 0.649667, -0.000000, 0.760219, -0.000000, 1.000000, 0.000000, -0.760219, -0.000000, 0.649667),
   ["Tropical Grove"] = CFrame.new(-2134.633301, 6.646839, 3641.041016, -0.787255, 0.000000, -0.616627, 0.000000, 1.000000, -0.000000, 0.616627, -0.000000, -0.787255),
   ["Tropical Grove 2"] = CFrame.new(-2202.405762, 25.430653, 3607.925781, 0.457824, 0.000000, 0.889043, 0.000000, 1.000000, -0.000000, -0.889043, 0.000000, 0.457824),
   ["Sisyphus Statue"] = CFrame.new(-3730.283203, -99.316132, -947.356995, 0.871698, 0.000000, 0.490044, -0.000000, 1.000000, 0.000000, -0.490044, -0.000000, 0.871698),
   ["Weather Machine"] = CFrame.new(-1541.473877, 2.875000, 1918.276733, -0.984437, 0.000000, 0.175738, 0.000000, 1.000000, -0.000000, -0.175738, -0.000000, -0.984437),
   ["Treasure Room"] = CFrame.new(-3650.865479, -279.073822, -1615.960327, 0.518514, -0.000000, -0.855069, 0.000000, 1.000000, 0.000000, 0.855069, -0.000000, 0.518514),
   ["Esoteric Island"] = CFrame.new(1988.061768, 7.207217, 1363.772339, 0.031890, -0.000000, 0.999491, -0.000000, 1.000000, 0.000000, -0.999491, -0.000000, 0.031890),
   ["Crater Island"] = CFrame.new(991.782410, 7.904960, 5082.351562, -0.711836, -0.000000, 0.702345, 0.000000, 1.000000, 0.000000, -0.702345, 0.000000, -0.711836),
   ["Coral Reefs"] = CFrame.new(-3212.688477, 10.198070, 2004.139648, 0.778372, -0.000000, -0.627804, 0.000000, 1.000000, -0.000000, 0.627804, -0.000000, 0.778372),
   ["Stingray Shores"] = CFrame.new(-182.069839, 3.134159, 2789.177246, 0.013366, -0.000000, 0.999911, -0.000000, 1.000000, 0.000000, -0.999911, -0.000000, 0.013366),
   ["Ocean"] = CFrame.new(1756.653687, 2.299988, 3358.764893, 0.200904, -0.000000, -0.979611, 0.000000, 1.000000, -0.000000, 0.979611, -0.000000, 0.200904),
   ["Esoteric Depths"] = CFrame.new(3231.490234, -1302.105103, 1453.461060, 0.988762, 0.000000, -0.149498, -0.000000, 1.000000, -0.000000, 0.149498, 0.000000, 0.988762)
}
local FarmLocationDropdown = Tabs.Fishing:AddDropdown("FarmLocation", {
   Title = "Auto Farm V1 - Select Map",
   Description = "Choose location for auto farming",
   Values = {
      "Kohana", "Kohana Volcano", "Tropical Grove", "Tropical Grove 2",
      "Sisyphus Statue", "Weather Machine", "Treasure Room", "Esoteric Island",
      "Crater Island", "Coral Reefs", "Stingray Shores", "Ocean", "Esoteric Depths"
   },
   Multi = false,
   Default = 1,
})
FarmLocationDropdown:OnChanged(function(Value)
   selectedFarmLocation = Value
end)
local function startAutoFarm()
   if not selectedFarmLocation then return false end
   local player = game.Players.LocalPlayer
   if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end

   local targetCFrame = farmLocations[selectedFarmLocation]
   if targetCFrame then
      player.Character.HumanoidRootPart.CFrame = targetCFrame
      wait(2)

      -- aktifkan method sesuai dropdown
      if selectedFarmMethodV1 == "V1" then
         Options.AutoFishing:SetValue(true)
      else
          Options.AutoFishingV2:SetValue(true)
          Options.AutoClickV2:SetValue(true)
      end

      spawn(function()
         while isAutoFarmActive do
            wait(5)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
               local currentPos = player.Character.HumanoidRootPart.Position
               local targetPos = targetCFrame.Position
               local distance = (currentPos - targetPos).Magnitude
               if distance > 50 then
                  player.Character.HumanoidRootPart.CFrame = targetCFrame
                  -- refresh toggle
                  if selectedFarmMethodV1 == "V1" then
                     Options.AutoFishing:SetValue(false)
                     wait(1)
                     Options.AutoFishing:SetValue(true)
                  else
                     Options.AutoFishingV2:SetValue(false)
                     wait(1)
                     Options.AutoFishingV2:SetValue(true)
                  end
               end
            end
         end
      end)
      return true
   end
   return false
end
local function stopAutoFarm()
   isAutoFarmActive = false
   Options.AutoFishing:SetValue(false)
   Options.AutoFishingV2:SetValue(false)
    Options.AutoClickV2:SetValue(false)
end
local FarmMethodV1Dropdown = Tabs.Fishing:AddDropdown("FarmMethodV1", {
    Title = "Select Auto Fishing",
    Description = "for Auto Farm V1",
    Values = {"V1", "V2"},
    Multi = false,
    Default = 1,
})
FarmMethodV1Dropdown:OnChanged(function(Value)
    selectedFarmMethodV1 = Value
end)
local AutoFarmV1Toggle = Tabs.Fishing:AddToggle("AutoFarmV1", {
   Title = "Start Auto Farm V1",
   Description = "Start farming at selected location",
   Default = false,
   Callback = function(Value)
      if Value then
         if not isAutoFarmActive then
            isAutoFarmActive = true
            if not startAutoFarm() then
               isAutoFarmActive = false
               Options.AutoFarmV1:SetValue(false)
            end
         end
      else
         if isAutoFarmActive then
            stopAutoFarm()
         end
      end
   end,
})

-- Auto Farm V2
Tabs.Fishing:AddSection("Auto Farm V2")
local selectedFarmMethodV2 = "V1"
local isAutoFarmV2Active = false
local checkpointPosition = nil
local hasCheckpoint = false

local CheckpointInput = Tabs.Fishing:AddInput("CheckpointInput", {
    Title = "Don't touch this!",
    Description = "Checkpoint Status",
    Default = "",
    Placeholder = "......",
    Numeric = false,
    Finished = false,
    Callback = function(Value)
        -- Parse coordinate string back to CFrame if valid
        if Value and Value ~= "" then
            local coords = {}
            for num in Value:gmatch("([%-%d%.]+)") do
                table.insert(coords, tonumber(num))
            end
            if #coords >= 12 then
                checkpointPosition = CFrame.new(unpack(coords))
                hasCheckpoint = true
            end
        else
            checkpointPosition = nil
            hasCheckpoint = false
        end
    end
})

local function cframeToString(cframe)
    if not cframe then return "" end
    local components = {cframe:GetComponents()}
    return string.format("%.2f, %.2f, %.2f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f", unpack(components))
end

local SetCheckpointButton = Tabs.Fishing:AddButton({
    Title = "Set Location",
    Description = "Save current position as farming location",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            checkpointPosition = player.Character.HumanoidRootPart.CFrame
            hasCheckpoint = true
            local coordString = cframeToString(checkpointPosition)
            Options.CheckpointInput:SetValue(coordString)
        end
    end,
})

local ClearCheckpointButton = Tabs.Fishing:AddButton({
    Title = "Clear Location",
    Description = "Remove saved position",
    Callback = function()
        checkpointPosition = nil
        hasCheckpoint = false
        if isAutoFarmV2Active then
            Options.AutoFarmV2:SetValue(false)
        end
        Options.CheckpointInput:SetValue("")
    end,
})

local function startAutoFarmV2()
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end

    player.Character.HumanoidRootPart.CFrame = checkpointPosition
    wait(2)

    -- aktifkan method sesuai dropdown
    if selectedFarmMethodV2 == "V1" then
        Options.AutoFishing:SetValue(true)
    else
        Options.AutoFishingV2:SetValue(true)
        Options.AutoClickV2:SetValue(true)
    end

    spawn(function()
        while isAutoFarmV2Active do
            wait(5)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local currentPos = player.Character.HumanoidRootPart.Position
                local checkpointPos = checkpointPosition.Position
                local distance = (currentPos - checkpointPos).Magnitude
                if distance > 50 then
                    player.Character.HumanoidRootPart.CFrame = checkpointPosition
                    -- refresh toggle
                    if selectedFarmMethodV2 == "V1" then
                        Options.AutoFishing:SetValue(false)
                        wait(1)
                        Options.AutoFishing:SetValue(true)
                    else
                        Options.AutoFishingV2:SetValue(false)
                        wait(1)
                        Options.AutoFishingV2:SetValue(true)
                    end
                end
            end
        end
    end)
    return true
end

local FarmMethodV2Dropdown = Tabs.Fishing:AddDropdown("FarmMethodV2", {
    Title = "Select Auto Fishing",
    Description = "Choose fishing method for Auto Farm V2",
    Values = {"V1", "V2"},
    Multi = false,
    Default = 1,
})
FarmMethodV2Dropdown:OnChanged(function(Value)
    selectedFarmMethodV2 = Value
end)

local function stopAutoFarmV2()
    isAutoFarmV2Active = false
    Options.AutoFishing:SetValue(false)
    Options.AutoFishingV2:SetValue(false)
    Options.AutoClickV2:SetValue(false)
end

local AutoFarmV2Toggle = Tabs.Fishing:AddToggle("AutoFarmV2", {
    Title = "Start Auto Farm V2",
    Description = "Farm at your saved location",
    Default = false,
    Callback = function(Value)
        if Value then
            if not isAutoFarmV2Active then
                isAutoFarmV2Active = true
                if not startAutoFarmV2() then
                    isAutoFarmV2Active = false
                    Options.AutoFarmV2:SetValue(false)
                end
            end
        else
            if isAutoFarmV2Active then
                stopAutoFarmV2()
            end
        end
    end,
})

-- Enhanced respawn protection for Auto Farm V2
spawn(function()
    wait(5) -- tunggu config dan checkpoint input benar2 loaded
    if Options.AutoFarmV2 and Options.AutoFarmV2.Value == true then
        if hasCheckpoint and checkpointPosition then
            Options.AutoFarmV2:SetValue(false)
            wait(3)
            Options.AutoFarmV2:SetValue(true)
        else
            Options.AutoFarmV2:SetValue(false)
        end
    end
end)

spawn(function()
    wait(3) -- Wait untuk config loading selesai
    local inputValue = Options.CheckpointInput and Options.CheckpointInput.Value or ""
    if inputValue ~= "" then
        local coords = {}
        for num in inputValue:gmatch("([%-%d%.]+)") do
            table.insert(coords, tonumber(num))
        end
        if #coords >= 12 then
            checkpointPosition = CFrame.new(unpack(coords))
            hasCheckpoint = true
            local pos = checkpointPosition.Position
            local infoText = string.format("X: %.1f, Y: %.1f, Z: %.1f", pos.X, pos.Y, pos.Z)
        end
    end
end)

-- Global cleanup on player leaving/respawning
local Players = game:GetService("Players")
local player = Players.LocalPlayer

if player then
    player.CharacterRemoving:Connect(function()
        isAutoFishV2Active = false
        isAutoClickV2Active = false
        isInstantReelActive = false
        isWaitingForCompletion = false
        
        if characterConnection then
            characterConnection:Disconnect()
            characterConnection = nil
        end
        if instantReelConnection then
            instantReelConnection:Disconnect()
            instantReelConnection = nil
        end
        if fishingCompletionConnection then
            fishingCompletionConnection:Disconnect()
            fishingCompletionConnection = nil
        end
        resetFishingController()
        if Options then
            pcall(function() if Options.AutoFishingV2 then Options.AutoFishingV2:SetValue(false) end end)
            pcall(function() if Options.AutoClickV2 then Options.AutoClickV2:SetValue(false) end end)
            pcall(function() if Options.instrail then Options.instrail:SetValue(false) end end)
        end
    end)
    player.CharacterAdded:Connect(function()
        resetFishingController()
        lastToolRefreshTimeV2 = 0
        isWaitingForCompletion = false
        wait(2)
    end)
end
end
do
    local teleportTab = Tabs.Teleport
    
    -- Player Teleport Section
    local currentPlayerList = {}
    local isDropdownInitialized = false
    local lastSelectedOption = "Select a player..."

    local function getPlayerList()
        local players = {}
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                table.insert(players, player.Name)
            end
        end
        return players
    end

    local function updatePlayerDropdown()
        currentPlayerList = getPlayerList()
        if Options.TeleportToPlayer then
            if #currentPlayerList > 0 then
                local options = {"Select a player..."}
                for _, playerName in ipairs(currentPlayerList) do
                    table.insert(options, playerName)
                end
                Options.TeleportToPlayer:SetValues(options)
            end
        end
    end

    local function teleportToPlayer(playerName)
        if not isDropdownInitialized then return end
        if playerName == lastSelectedOption then return end
        lastSelectedOption = playerName
        if playerName == "No players available" or playerName == "Select a player..." then
            return
        end

        local success, error = pcall(function()
            local targetPlayer = game.Players:FindFirstChild(playerName)
            local localPlayer = game.Players.LocalPlayer

            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                return
            end

            if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                return
            end

            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local offsetPosition = targetPosition + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(offsetPosition)
        end)
    end

    currentPlayerList = getPlayerList()
    local playerTeleportDropdown = teleportTab:AddDropdown("TeleportToPlayer", {
        Title = "Teleport To Player",
        Description = "Select a player to teleport to",
        Values = #currentPlayerList > 0 and (function() 
            local options = {"Select a player..."}
            for _, playerName in ipairs(currentPlayerList) do
                table.insert(options, playerName)
            end
            return options
        end)() or {"Select a player...", "No players available"},
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select a player..." or Value == "No players available" then
                return
            end
            
            if Value and isDropdownInitialized then
                spawn(function()
                    wait(0.1)
                    teleportToPlayer(Value)
                    -- Reset to default after teleport
                    Options.TeleportToPlayer:SetValue("Select a player...")
                end)
            end
        end
    })

    spawn(function()
        wait(2)
        isDropdownInitialized = true
    end)

    local refreshPlayerButton = teleportTab:AddButton({
        Title = "Refresh Player List",
        Description = "Update the list of available players",
        Callback = function()
            updatePlayerDropdown()
        end
    })

    -- Island Teleport Section
    teleportTab:AddSection("Islands")
    
    local islandTeleportDropdown = teleportTab:AddDropdown("TeleportIsland", {
        Title = "Teleport To Island",
        Description = "Select an island to teleport to",
        Values = {
            "Select Island...",
            "Kohana",
            "Kohana Volcano",
            "Tropical Grove",
            "Sisyphus Statue",
            "Weather Machine",
            "Treasure Room",
            "Esoteric Island",
            "Crater Island",
            "Coral Reefs",
            "Stingray Shores",
            "Ocean",
            "Esoteric Depths"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Island..." then
                return
            end
            
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            local locations = {
                ["Kohana"] = CFrame.new(-666.27771, 0.946365654, 719.934326, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                ["Kohana Volcano"] = CFrame.new(-484.600891, 20.750059, 227.483047, -0.750139, -0.000000, -0.661280, -0.000000, 1.000000, -0.000000, 0.661280, 0.000000, -0.750139),
                ["Tropical Grove"] = CFrame.new(-2063.47021, 3.99908447, 3643.12622, -0.0675487518, 0, 0.99771595, 0, 1, 0, -0.99771595, 0, -0.0675487518),
                ["Sisyphus Statue"] = CFrame.new(-3729.36743, -100.94648, -948.056519, 0.881157279, -0.202546716, 0.427243084, 9.03755426e-06, 0.90360719, 0.428362042, -0.472823232, -0.377450496, 0.796221912),
                ["Weather Machine"] = CFrame.new(-1492.293091, 3.500000, 1903.266235, 0.037160, -0.000000, -0.999309, -0.000000, 1.000000, -0.000000, 0.999309, 0.000000, 0.037160),
                ["Treasure Room"] = CFrame.new(-3599.518799, -315.629181, -1418.691650, 0.999777, -0.000000, -0.021134, 0.000000, 1.000000, -0.000000, 0.021134, 0.000000, 0.999777),
                ["Esoteric Island"] = CFrame.new(2061.76196, 35.6500702, 1380.32703, 1, 0, 0, 0, 1, 0, 0, 0, 1),
                ["Crater Island"] = CFrame.new(976.711548, -5.2534189, 4886.73242, 0.173624337, -0, -0.984811902, 0, 1, -0, 0.984811902, 0, 0.173624337),
                ["Coral Reefs"] = CFrame.new(-3120.34644, 16.9453125, 2181.97144, 0.707134247, -0, -0.707079291, 0, 1, -0, 0.707079291, 0, 0.707134247),
                ["Stingray Shores"] = CFrame.new(32.029018, 9.784778, 2813.289551, 0.980407, -0.000000, 0.196984, 0.000000, 1.000000, -0.000000, -0.196984, 0.000000, 0.980407),
                ["Ocean"] = CFrame.new(1609.45593, 7.993308318, 3279.21533, 0.499959469, 0, 0.866048813, 0, 1, 0, -0.866048813, 0, 0.499959469),
                ["Esoteric Depths"] = CFrame.new(3054.9707, -1288.35474, 1483.97412, 0.90629667, 0, 0.422642082, 0, 1, 0, -0.422642082, 0, 0.90629667)
            }
            if locations[Value] then
                player.Character.HumanoidRootPart.CFrame = locations[Value]
                spawn(function()
                    wait(0.1)
                    Options.TeleportIsland:SetValue("Select Island...")
                end)
            end
        end
    })

    -- NPC Teleport Section  
    teleportTab:AddSection("NPCs")
    
    local npcTeleportDropdown = teleportTab:AddDropdown("TeleportNPC", {
        Title = "Teleport To NPC",
        Description = "Select an NPC to teleport to",
        Values = {
            "Select NPC...",
            "Alex - Sell Fish",
            "Billy Bob - Rod Skin",
            "Boat Expert - Boat Shop",
            "Joe - Rod Shop",
            "Scientist - Lucky Potion",
            "Scoot - Boat Shop",
            "Seth - Bait Shop",
            "Silly Fisherman"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select NPC..." then
                return
            end
            
            local player = game.Players.LocalPlayer
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            
            local npcLocations = {
                ["Alex - Sell Fish"] = CFrame.new(48.656158, 17.071970, 2868.007812, -0.997883, 0.000000, 0.065036, 0.000000, 1.000000, -0.000000, -0.065036, -0.000000, -0.997883),
                ["Billy Bob - Rod Skin"] = CFrame.new(80.990456, 17.071970, 2869.381348, -0.958304, 0.000000, 0.285750, 0.000000, 1.000000, -0.000000, -0.285750, -0.000000, -0.958304),
                ["Boat Expert - Boat Shop"] = CFrame.new(22.869276, 4.045772, 2810.912354, 0.999303, -0.000000, 0.037339, 0.000000, 1.000000, 0.000000, -0.037339, -0.000000, 0.999303),
                ["Joe - Rod Shop"] = CFrame.new(142.136551, 20.459019, 2855.692871, -0.993222, 0.000000, -0.116233, 0.000000, 1.000000, -0.000000, 0.116233, -0.000000, -0.993222),
                ["Scientist - Lucky Potion"] = CFrame.new(-7.974049, 4.500001, 2844.862305, -0.999788, -0.000000, -0.020568, -0.000000, 1.000000, 0.000000, 0.020568, 0.000000, -0.999788),
                ["Scoot - Boat Shop"] = CFrame.new(-75.6783218, 4.74903107, 2867.15674, 0.305231869, -2.02933879e-05, 0.952278197, 0.000808718964, 0.999999642, -0.000237909742, -0.952277839, 0.000842742971, 0.30523181),
                ["Seth - Bait Shop"] = CFrame.new(112.343651, 17.071970, 2869.337402, -0.953610, 0.000000, 0.301044, -0.000000, 1.000000, -0.000000, -0.301044, -0.000000, -0.953610),
                ["Silly Fisherman"] = CFrame.new(90.683128, 27.244699, 3005.096436, -0.739958, 0.000000, -0.672653, 0.000000, 1.000000, 0.000000, 0.672653, 0.000000, -0.739958)
            }
            
            if npcLocations[Value] then
                player.Character.HumanoidRootPart.CFrame = npcLocations[Value]
                spawn(function()
                    wait(0.1)
                    Options.TeleportNPC:SetValue("Select NPC...")
                end)
            end
        end
    })
-- Complete Auto Event Teleport System - Updated with Megalodon Hunt
teleportTab:AddSection("Events")

local eventCoordinates = {
    ["Shark Hunt"] = {
        Vector3.new(1.64999, 5, 2095.72),
        Vector3.new(1369.94, 5, 930.125),
        Vector3.new(-1585.5, 5, 1242.87),
        Vector3.new(-1896.8, 5, 2634.37)
    },
    ["Ghost Shark Hunt"] = {
        Vector3.new(489.558, 5, 25.4060),
        Vector3.new(1976.51, 5, 2915.93),
        Vector3.new(-1358.2, 5, 4100.55),
        Vector3.new(627.859, 5, 3798.08)
    },
    ["Megalodon Hunt"] = {
        Vector3.new(-1076.3, 5, 1676.19),
        Vector3.new(-1191.8, 5, 3597.30),
        Vector3.new(412.700, 5, 4134.39)
    },
    ["Sparkling Cove"] = {
        Vector3.new(195.378, 5, 2976.27)
    },
    ["Worm Hunt"] = {
        Vector3.new(1591.55, 5, -105.92),
        Vector3.new(-2450.6, 5, 139.731),
        Vector3.new(-267.47, 5, 5188.53)
    },
    ["Admin - Shocked"] = {
        Vector3.new(383, 5, 2452)
    },
    ["Admin - Black Hole"] = {
        Vector3.new(883, 5, 2542)
    },
    ["Admin - Ghost Worm"] = {
        Vector3.new(-327, 5, 2422)
    },
    ["Admin - Meteor Rain"] = {
        Vector3.new(383, 5, 2452)
    }
}

-- Variables with anti-spam protection
local selectedEvents = {}
local autoTeleportEnabled = false
local teleportRadius = 20
local savedPosition = nil
local currentEventName = nil
local currentEventPosition = nil
local hasTeleportedToEvent = false
local lastTeleportTime = 0
local teleportCooldown = 10 -- 10 second cooldown

-- Function to detect active events
local function getActiveEvents()
    local activeEvents = {}
    
    pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local LocalPlayer = game.Players.LocalPlayer
        local workspace = game:GetService("Workspace")
        
        -- Method 1: Check Replion system
        local Client = ReplicatedStorage.Packages:FindFirstChild("Replion")
        if Client then
            local clientModule = require(Client).Client
            local eventsReplion = clientModule:WaitReplion("Events", 1)
            if eventsReplion then
                local eventsList = eventsReplion:GetExpected("Events")
                if eventsList then
                    for _, eventName in ipairs(eventsList) do
                        if eventName and eventName ~= "" then
                            table.insert(activeEvents, eventName)
                        end
                    end
                end
            end
        end
        
        -- Method 2: Check PlayerGui
        local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if PlayerGui then
            local eventsGui = PlayerGui:FindFirstChild("Events")
            if eventsGui and eventsGui:FindFirstChild("Frame") then
                local eventsFrame = eventsGui.Frame:FindFirstChild("Events")
                if eventsFrame then
                    for _, eventTile in pairs(eventsFrame:GetChildren()) do
                        if eventTile:IsA("GuiObject") and eventTile.Visible and 
                           eventTile.Name ~= "UIListLayout" and eventTile.Name ~= "UIPadding" then
                            local eventName = eventTile.Name
                            local exists = false
                            for _, existing in pairs(activeEvents) do
                                if existing == eventName then
                                    exists = true
                                    break
                                end
                            end
                            if not exists then
                                table.insert(activeEvents, eventName)
                            end
                        end
                    end
                end
            end
        end
        
        -- Method 3: Check Props folder
        local props = workspace:FindFirstChild("Props")
        if props then
            for _, prop in pairs(props:GetChildren()) do
                local propName = string.lower(prop.Name)
                
                if string.find(propName, "shark") and string.find(propName, "hunt") then
                    if string.find(propName, "ghost") then
                        local exists = false
                        for _, existing in pairs(activeEvents) do
                            if existing == "Ghost Shark Hunt" then
                                exists = true
                                break
                            end
                        end
                        if not exists then
                            table.insert(activeEvents, "Ghost Shark Hunt")
                        end
                    else
                        local exists = false
                        for _, existing in pairs(activeEvents) do
                            if existing == "Shark Hunt" then
                                exists = true
                                break
                            end
                        end
                        if not exists then
                            table.insert(activeEvents, "Shark Hunt")
                        end
                    end
                elseif string.find(propName, "megalodon") and string.find(propName, "hunt") then
                    local exists = false
                    for _, existing in pairs(activeEvents) do
                        if existing == "Megalodon Hunt" then
                            exists = true
                            break
                        end
                    end
                    if not exists then
                        table.insert(activeEvents, "Megalodon Hunt")
                    end
                elseif string.find(propName, "worm") and string.find(propName, "hunt") then
                    local exists = false
                    for _, existing in pairs(activeEvents) do
                        if existing == "Worm Hunt" then
                            exists = true
                            break
                        end
                    end
                    if not exists then
                        table.insert(activeEvents, "Worm Hunt")
                    end
                elseif string.find(propName, "sparkling") or string.find(propName, "cove") then
                    local exists = false
                    for _, existing in pairs(activeEvents) do
                        if existing == "Sparkling Cove" then
                            exists = true
                            break
                        end
                    end
                    if not exists then
                        table.insert(activeEvents, "Sparkling Cove")
                    end
                end
            end
        end
    end)
    
    return activeEvents
end

local function getEventLocation(eventName)
    if not eventCoordinates[eventName] then
        return nil
    end
    local coords = eventCoordinates[eventName]
    if #coords == 1 then
        return coords[1]
    end
    local bestCoord = nil
    local highestScore = 0
    
    local success, result = pcall(function()
        local workspace = game:GetService("Workspace")
        local props = workspace:FindFirstChild("Props")
        if props then
            for _, prop in pairs(props:GetChildren()) do
                local propName = string.lower(prop.Name)
                local isEventMatch = false
                
                if eventName == "Shark Hunt" and string.find(propName, "shark") and string.find(propName, "hunt") and not string.find(propName, "ghost") and not string.find(propName, "megalodon") then
                    isEventMatch = true
                elseif eventName == "Ghost Shark Hunt" and (string.find(propName, "ghost") and string.find(propName, "shark")) then
                    isEventMatch = true
                elseif eventName == "Megalodon Hunt" and string.find(propName, "megalodon") and string.find(propName, "hunt") then
                    isEventMatch = true
                elseif eventName == "Worm Hunt" and string.find(propName, "worm") and string.find(propName, "hunt") then
                    isEventMatch = true
                elseif eventName == "Sparkling Cove" and (string.find(propName, "sparkling") or string.find(propName, "cove")) then
                    isEventMatch = true
                end
                
                if isEventMatch then
                    local propPosition
                    if prop:IsA("Model") and prop.PrimaryPart then
                        propPosition = prop.PrimaryPart.Position
                    elseif prop:IsA("Model") then
                        propPosition = prop:GetPivot().Position
                    elseif prop:IsA("Part") then
                        propPosition = prop.Position
                    end
                    
                    if propPosition then
                        local closestDistance = math.huge
                        local closestCoord = nil
                        for i, coord in ipairs(coords) do
                            local distance = (propPosition - coord).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestCoord = coord
                            end
                        end
                        if closestCoord and closestDistance < 2000 then
                            return closestCoord
                        end
                    end
                end
            end
        end
        return coords[1]
    end)
    
    if success and result then
        return result
    else
        return coords[1]
    end
end

local function saveCurrentPosition()
    if savedPosition then
        return true
    end
    
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        savedPosition = player.Character.HumanoidRootPart.CFrame
        return true
    end
    return false
end

local function isPlayerNearEvent()
    if not currentEventPosition or not hasTeleportedToEvent then
        return false
    end
    
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local currentPosition = player.Character.HumanoidRootPart.Position
    local distance = (currentPosition - currentEventPosition).Magnitude
    
    return distance <= teleportRadius
end

local function teleportToEvent(eventName)
    local currentTime = tick()
    if currentTime - lastTeleportTime < teleportCooldown then
        local remainingCooldown = teleportCooldown - (currentTime - lastTeleportTime)
        return false
    end
    
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    if not savedPosition then
        saveCurrentPosition()
    end
    
    local targetPos = getEventLocation(eventName)
    if targetPos then
        local backwardOffset = Vector3.new(0, 0, 15) -- 10m backward
        local offsetPos = targetPos + Vector3.new(
            math.random(-5, 5), -- Random X offset (smaller range since we're moving back)
            -3, -- Lower by 2m from original position
            math.random(-5, 5) -- Random Z offset
        ) + backwardOffset -- Add 10m backward
        
        player.Character.HumanoidRootPart.CFrame = CFrame.new(offsetPos)
        currentEventName = eventName
        currentEventPosition = targetPos
        hasTeleportedToEvent = true
        lastTeleportTime = currentTime
        
        if Options.FlyToggle then
            Options.FlyToggle:SetValue(true)
        end
        return true
    else
        warn("No coordinates found for " .. eventName)
        return false
    end
end

local function returnToSavedPosition()
    local player = game.Players.LocalPlayer
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    if savedPosition then
        local success, err = pcall(function()
            player.Character.HumanoidRootPart.CFrame = savedPosition
        end)
        if success then
            return true
        else
            warn("Failed to return to saved position: " .. tostring(err))
            return false
        end
    else
        return false
    end
end

local function resetTracking()
    currentEventName = nil
    currentEventPosition = nil
    hasTeleportedToEvent = false
    savedPosition = nil
    lastTeleportTime = 0
end

local function checkAndTeleportToSelectedEvents()
    if not autoTeleportEnabled or #selectedEvents == 0 then
        return
    end
    
    local currentTime = tick()
    if currentTime - lastTeleportTime < teleportCooldown then
        return -- Still in cooldown, don't check anything
    end
    
    local activeEvents = getActiveEvents()
    local activeSelectedEvent = nil
    
    for _, selectedEvent in pairs(selectedEvents) do
        for _, activeEvent in pairs(activeEvents) do
            if selectedEvent == activeEvent then
                activeSelectedEvent = selectedEvent
                break
            end
        end
        if activeSelectedEvent then break end
    end
    
    if activeSelectedEvent then
        if not hasTeleportedToEvent then
            teleportToEvent(activeSelectedEvent)
        elseif currentEventName ~= activeSelectedEvent then
            teleportToEvent(activeSelectedEvent)
        elseif not isPlayerNearEvent() then
            -- MOVED AWAY: Same event but player moved away
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and currentEventPosition then
                local distance = (player.Character.HumanoidRootPart.Position - currentEventPosition).Magnitude
                teleportToEvent(activeSelectedEvent)
            end
        else
        end
    else
        if hasTeleportedToEvent then
            if returnToSavedPosition() then
                resetTracking()
            end
        end
    end
end

-- UI Components
local eventDropdown = teleportTab:AddDropdown("SelectEvents", {
    Title = "Select Events",
    Description = "Choose which events to automatically teleport to when they become active",
    Values = {"Shark Hunt", "Ghost Shark Hunt", "Megalodon Hunt", "Sparkling Cove", "Worm Hunt", 
              "Admin - Shocked", "Admin - Black Hole", "Admin - Ghost Worm", "Admin - Meteor Rain"},
    Multi = true,
    Default = {},
})

eventDropdown:OnChanged(function(Value)
    local Values = {}
    if type(Value) == "table" then
        for k, v in pairs(Value) do
        end
        if #Value > 0 then
            Values = Value
        else
            for EventName, State in pairs(Value) do
                if State == true then
                    table.insert(Values, EventName)
                end
            end
        end
    elseif Value then
        Values = {Value}
    end
    selectedEvents = Values
end)

local autoTeleportToggle = teleportTab:AddToggle("AutoTeleportEvents", {
    Title = "Auto Teleport to Events",
    Description = "Enable/disable automatic teleportation to selected events",
    Default = false,
})

autoTeleportToggle:OnChanged(function(value)
    autoTeleportEnabled = value
    if value then
        
    else
        if hasTeleportedToEvent and savedPosition then
            returnToSavedPosition()
        end
        resetTracking()
    end
end)

spawn(function()
    while true do
        wait(5) -- Check every 5 seconds
        if autoTeleportEnabled then
            local success, err = pcall(checkAndTeleportToSelectedEvents)
            if not success then
                warn("Error in auto-teleport: " .. tostring(err))
            end
        end
        
        local statusText = ""
        if autoTeleportEnabled and #selectedEvents > 0 then
            local cooldownRemaining = math.max(0, teleportCooldown - (tick() - lastTeleportTime))
            if cooldownRemaining > 0 then
                statusText = "ACTIVE - Cooldown: " .. math.ceil(cooldownRemaining) .. "s"
            elseif hasTeleportedToEvent then
                statusText = "ACTIVE - Monitoring " .. (currentEventName or "events") .. " (Near: " .. tostring(isPlayerNearEvent()) .. ")"
            else
                statusText = "ACTIVE - Waiting for events: " .. table.concat(selectedEvents, ", ")
            end
        elseif autoTeleportEnabled then
            statusText = "ENABLED - No events selected"
        else
            statusText = "DISABLED"
        end
    end
end)
    -- local copycords = teleportTab:AddButton({
    --     Title = "Copy Coords",
    --     Description = "copy coords",
    --     Callback = function()
    --                 local player = game.Players.LocalPlayer
    --     if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
    --         local pos = player.Character.HumanoidRootPart.CFrame
    --         -- Format ke string
    --         local coordsString = string.format(
    --             "CFrame.new(%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f)",
    --             pos:GetComponents()
    --         )
    --         setclipboard(coordsString)
    --     end
    --     end
    -- })
end

do
    local buyTab = Tabs.Buy
    
    -- Buy Weather Section
    local weatherDropdown = buyTab:AddDropdown("BuyWeather", {
        Title = "Buy Weather",
        Description = "Purchase weather events with coins",
        Values = {
            "Select Weather...",
            "Cloudy (20,000)",
            "Wind (10,000)",
            "Snow (15,000)",
            "Storm (35,000)",
            "Shark Hunt (300,000)"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Weather..." then
                return
            end
            
            local weatherName
            if Value:find("Cloudy") then
                weatherName = "Cloudy"
            elseif Value:find("Wind") then
                weatherName = "Wind"
            elseif Value:find("Snow") then
                weatherName = "Snow"
            elseif Value:find("Storm") then
                weatherName = "Storm"
            elseif Value:find("Shark Hunt") then
                weatherName = "Shark Hunt"
            end
            
            if weatherName then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyWeather = net:FindFirstChild("RF/PurchaseWeatherEvent")
                        if buyWeather then
                            buyWeather:InvokeServer(weatherName)
                        else
                            warn("PurchaseWeatherEvent not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Weather purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyWeather:SetValue("Select Weather...")
                end)
            end
        end
    })
    
    -- Buy Rod Section
    buyTab:AddSection("Fishing Equipment")
    
    local rodDropdown = buyTab:AddDropdown("BuyRod", {
        Title = "Buy Fishing Rod",
        Description = "Purchase fishing rods to improve your fishing",
        Values = {
            "Select Rod...",
            "Lucky Rod - 350",
            "Carbon Rod - 900",
            "Grass Rod - 1,500",
            "Damascus Rod - 3,000",
            "Ice Rod - 5,000",
            "Lucky Rod Pro - 15,000",
            "Midnight Rod - 50,000",
            "Steampunk Rod - 215,000",
            "Chrome Rod - 437,000",
            "Astral Rod - 1,000,000"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Rod..." then
                return
            end
            
            local rodId
            local rodName = Value
            
            if Value:find("Lucky Rod - 350") then
                rodId = 79
            elseif Value:find("Carbon Rod") then
                rodId = 76
            elseif Value:find("Grass Rod") then
                rodId = 85
            elseif Value:find("Damascus Rod") then
                rodId = 77
            elseif Value:find("Ice Rod") then
                rodId = 78
            elseif Value:find("Lucky Rod Pro") then
                rodId = 4
            elseif Value:find("Midnight Rod") then
                rodId = 80
            elseif Value:find("Steampunk Rod") then
                rodId = 6
            elseif Value:find("Chrome Rod") then
                rodId = 7
            elseif Value:find("Astral Rod") then
                rodId = 5
            end
            
            if rodId then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyRod = net:FindFirstChild("RF/PurchaseFishingRod")
                        if buyRod then
                            buyRod:InvokeServer(rodId)
                        else
                            warn("PurchaseFishingRod not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Rod purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyRod:SetValue("Select Rod...")
                end)
            end
        end
    })
    
    -- Buy Bait Section
    local baitDropdown = buyTab:AddDropdown("BuyBait", {
        Title = "Buy Bait",
        Description = "Purchase different types of bait for better catches",
        Values = {
            "Select Bait...",
            "Topwater Bait - 100",
            "Lucky Bait - 1,000",
            "Midnight Bait - 3,000",
            "Chroma Bait - 290,000",
            "Dark Matter Bait - 630,000",
            "Corrupt Bait - 1,150,000"
        },
        Multi = false,
        Default = 1,
        Searchable = true,
        Callback = function(Value)
            if Value == "Select Bait..." then
                return
            end
            
            local baitId
            local baitName = Value
            
            if Value:find("Topwater Bait") then
                baitId = 10
            elseif Value:find("Lucky Bait") then
                baitId = 2
            elseif Value:find("Midnight Bait") then
                baitId = 3
            elseif Value:find("Chroma Bait") then
                baitId = 6
            elseif Value:find("Dark Matter Bait") then
                baitId = 8
            elseif Value:find("Corrupt Bait") then
                baitId = 15
            end
            
            if baitId then
                local success, error = pcall(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local netFolder = ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
                    if netFolder and netFolder:FindFirstChild("net") then
                        local net = netFolder.net
                        local buyBait = net:FindFirstChild("RF/PurchaseBait")
                        if buyBait then
                            buyBait:InvokeServer(baitId)
                        else
                            warn("PurchaseBait not found!")
                        end
                    end
                end)
                
                if not success then
                    warn("Bait purchase error: " .. tostring(error))
                end
                
                -- Reset to default after purchase
                spawn(function()
                    wait(0.1)
                    Options.BuyBait:SetValue("Select Bait...")
                end)
            end
        end
    })
    
end
do
    local settingTab = Tabs.Settings
    
    -- FPS Boost Section
    settingTab:AddSection("Performance")
    
    local fpsBoostButton = settingTab:AddButton({
        Title = "FPS Boost",
        Description = "Boost performance by disabling graphics effects",
        Callback = function()
            local success, error = pcall(function()
                game.Lighting.GlobalShadows = false
                settings().Rendering.QualityLevel = Enum.QualityLevel.Level03
                
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Enabled = false
                    end
                end
                
                for _, effect in pairs(game.Lighting:GetChildren()) do
                    if effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") 
                    or effect:IsA("DepthOfFieldEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = false
                    end
                end
            end)
            
            if not success then
                warn("FPS Boost error: " .. tostring(error))
            end
        end
    })
    
    local resetFpsButton = settingTab:AddButton({
        Title = "Reset FPS Boost",
        Description = "Restore original graphics settings",
        Callback = function()
            local success, error = pcall(function()
                game.Lighting.GlobalShadows = true
                settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
                
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Enabled = true
                    end
                end
                
                for _, effect in pairs(game.Lighting:GetChildren()) do
                    if effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") 
                    or effect:IsA("DepthOfFieldEffect") or effect:IsA("ColorCorrectionEffect") then
                        effect.Enabled = true
                    end
                end
            end)
            if not success then
                warn("Reset FPS Boost error: " .. tostring(error))
            end
        end
    })
        local clearConfigButton = settingTab:AddButton({
        Title = "Clear Config",
        Description = "Remove Settings",
        Callback = function()
            local filePath = AutoConfig:GetFilePath()
            if isfile(filePath) then
                local success, err = pcall(function()
                    delfile(filePath)
                end)
                if success then
                    Fluent:Notify({
                        Title = "Settings",
                        Content = "Success.",
                        Duration = 5
                    })
                else
                    Fluent:Notify({
                        Title = "Settings",
                        Content = "Error",
                        Duration = 5
                    })
                end
            else
                Fluent:Notify({
                    Title = "Settings",
                    Content = "No configuration found.",
                    Duration = 5
                })
            end
        end
    })
    settingTab:AddSection("Server Management")
    local rejoinButton = settingTab:AddButton({
        Title = "Rejoin Server",
        Description = "Rejoin the current server",
        Callback = function()
            local player = game.Players.LocalPlayer
            local TeleportService = game:GetService("TeleportService")
            
            local success, err = pcall(function()
                TeleportService:Teleport(game.PlaceId, player)
            end)
            
            if not success then
                warn("Rejoin failed: " .. tostring(err))
            end
        end
    })
    local isAutoReconnectActive = false
    local reconnectAttempts = 0
    local maxReconnectAttempts = 3
    local reconnectData = {
        PlaceId = game.PlaceId,
        JobId = game.JobId or "",
        ServerInfo = game.JobId and game.JobId ~= "" and "Same Server" or "Random Server"
    }
    local function attemptReconnect()
        if not isAutoReconnectActive then return end
        reconnectAttempts = reconnectAttempts + 1
        local TeleportService = game:GetService("TeleportService")
        
        if reconnectAttempts <= 2 and reconnectData.JobId ~= "" then
            local success = pcall(function()
                TeleportService:TeleportToPlaceInstance(
                    reconnectData.PlaceId,
                    reconnectData.JobId,
                    game.Players.LocalPlayer
                )
            end)
            if success then
                return true
            end
        end
        if reconnectAttempts >= 2 or reconnectData.JobId == "" then
            local success = pcall(function()
                TeleportService:Teleport(reconnectData.PlaceId, game.Players.LocalPlayer)
            end)
            if success then
                return true
            end
        end
        if reconnectAttempts >= maxReconnectAttempts then
            reconnectAttempts = 0
            wait(10) 
        end
        return false
    end
    local autoReconnectToggle = settingTab:AddToggle("AutoReconnect", {
        Title = "Auto Reconnect",
        Description = "Automatically reconnect when disconnected",
        Default = false,
        Callback = function(Value)
            isAutoReconnectActive = Value
            reconnectAttempts = 0
            
            if Value then
                local serverType = reconnectData.JobId ~= "" and "Same Server First" or "Random Server"
            end
        end
    })
    spawn(function()
        local failCount = 0
        while wait(2) do
            if isAutoReconnectActive then
                local success = pcall(function()
                    local _ = game.Players.LocalPlayer.Character
                    local _ = game.Players.LocalPlayer.UserId
                    local _ = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                end)
                if not success then
                    failCount = failCount + 1
                    if failCount >= 3 then
                        for i = 1, 3 do
                            wait(3)
                            if attemptReconnect() then
                                break
                            end
                            wait(2)
                        end
                        failCount = 0
                    end
                else
                    failCount = 0
                end
            end
        end
    end)
    local function onErrorMessage()
        if not isAutoReconnectActive then return end
        wait(2) 
        spawn(function()
            for i = 1, 3 do
                if attemptReconnect() then
                    break
                end
                wait(3)
            end
        end)
    end
    pcall(function()
        game:GetService("GuiService").ErrorMessageChanged:Connect(function(msg)
            if isAutoReconnectActive and msg and msg ~= "" then
                if string.find(string.lower(msg), "disconnected") or 
                   string.find(string.lower(msg), "connection") or
                   string.find(string.lower(msg), "lost") or
                   string.find(string.lower(msg), "kick") then
                    onErrorMessage()
                end
            end
        end)
    end)
    pcall(function()
        game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
            if not isAutoReconnectActive then return end
            wait(0.5)
            if child.Name == "ErrorPrompt" then
                local reconnectButton = nil
                for _, desc in ipairs(child:GetDescendants()) do
                    if desc:IsA("TextButton") or desc:IsA("ImageButton") then
                        local text = desc.Text or ""
                        if string.find(string.lower(text), "reconnect") or 
                           string.find(string.lower(text), "retry") or
                           string.find(string.lower(text), "join") then
                            reconnectButton = desc
                            break
                        end
                    end
                end
                if reconnectButton then
                    pcall(function()
                        for i = 1, 3 do
                            firesignal(reconnectButton.MouseButton1Click)
                            firesignal(reconnectButton.Activated)
                            wait(0.5)
                        end
                    end)
                else
                    wait(2)
                    attemptReconnect()
                end
            end
        end)
    end)
    game.Players.LocalPlayer.OnTeleport:Connect(function(state)
        if not isAutoReconnectActive then return end
        if state == Enum.TeleportState.Failed then
            wait(3)
            attemptReconnect()
        end
    end)
    game.Players.PlayerRemoving:Connect(function(player)
        if player == game.Players.LocalPlayer and isAutoReconnectActive then
            attemptReconnect()
        end
    end)
    spawn(function()
        local RunService = game:GetService("RunService")
        local lastHeartbeat = tick()
        local timeout = 15 
        RunService.Heartbeat:Connect(function()
            lastHeartbeat = tick()
        end)
        while wait(5) do
            if isAutoReconnectActive then
                local timeSinceHeartbeat = tick() - lastHeartbeat
                if timeSinceHeartbeat > timeout then
                    lastHeartbeat = tick()
                    spawn(function()
                        attemptReconnect()
                    end)
                    wait(20) 
                end
            end
        end
    end)
    _G.ReconnectSameServer = function()
        if reconnectData.JobId ~= "" then
            game:GetService("TeleportService"):TeleportToPlaceInstance(
                reconnectData.PlaceId,
                reconnectData.JobId,
                game.Players.LocalPlayer
            )
        end
    end
    _G.ReconnectRandomServer = function()
        game:GetService("TeleportService"):Teleport(
            reconnectData.PlaceId,
            game.Players.LocalPlayer
        )
    end
    settingTab:AddSection("Server Information")
    local serverType = reconnectData.JobId ~= "" and "Private/VIP Server" or "Public Server"
    local playerCount = #game.Players:GetPlayers()
    local serverInfoParagraph = settingTab:AddParagraph({
        Title = "Current Server Details",
        Content = string.format("Server Type: %s\nPlayers Online: %d\nPlace ID: %d\nJob ID: %s", 
            serverType, 
            playerCount, 
            game.PlaceId,
            reconnectData.JobId ~= "" and reconnectData.JobId or "N/A"
        )
    })
    spawn(function()
        while wait(5) do
            local currentPlayers = #game.Players:GetPlayers()
            if currentPlayers ~= playerCount then
                playerCount = currentPlayers
                serverInfoParagraph:Set({
                    Title = "Server Details",
                    Content = string.format("Server Type: %s\nPlayers Online: %d\nPlace ID: %d\nJob ID: %s", 
                        serverType, 
                        playerCount, 
                        game.PlaceId,
                        reconnectData.JobId ~= "" and reconnectData.JobId or "N/A"
                    )
                })
            end
        end
    end)
end ---zr
-- Enhanced Webhook Tab with Fish Price Display Toggle
do
    local WebhookTab = Tabs.Webhook

    -- Variables for price display
    local showFishPrices = false
    local priceDisplayConnection = nil
    local fishPriceOverlays = {}
    local cachedInventoryData = {}
    local inventoryDataConnection = nil

    -- Fish images mapping
    local fishImages = {
        -- Secret Fish
        [156] = "https://i.imgur.com/VAUGUBf.png", -- Giant Squid
        [136] = "https://i.imgur.com/taZohVB.png", -- Frostborn Shark
        [99] = "https://i.imgur.com/0mURszZ.png",  -- Great Christmas Whale
        [141] = "https://i.imgur.com/DGwZd1N.png", -- Great Whale
        [159] = "https://i.imgur.com/3qDECjI.png", -- Robot Kraken
        [145] = "https://i.imgur.com/nWiP04p.png", -- Worm Fish
        [176] = "https://i.imgur.com/0mURszZ.png", -- Ghost Worm Fish
        [83] = "https://i.imgur.com/b9lVzg6.png",  -- Ghost Shark
        [226] = "https://i.imgur.com/0mURszZ.png", -- Megalodon
        [228] = "https://i.imgur.com/0mURszZ.png", -- Lochaness Monster
        [225] = "https://i.imgur.com/0mURszZ.png", -- Scare
        [218] = "https://i.imgur.com/0mURszZ.png", -- Thin Armor Shark
        [206] = "https://i.imgur.com/0mURszZ.png", -- Monster Shark
        [195] = "https://i.imgur.com/0mURszZ.png", -- Crystal Crab
        [201] = "https://i.imgur.com/0mURszZ.png", -- Eerie Shark 
        [200] = "https://i.imgur.com/0mURszZ.png", -- Orca 
        [187] = "https://i.imgur.com/0mURszZ.png", -- Queen Carb 

        -- Mythic Fish
        [110] = "https://i.imgur.com/0mURszZ.png", -- Lined Cardinal Fish
        [97] = "https://i.imgur.com/0mURszZ.png",  -- Gingerbread Turtle
        [34] = "https://i.imgur.com/EPA4CXL.png",  -- Loggerhead Turtle
        [21] = "https://i.imgur.com/0mURszZ.png",  -- Hawks Turtle
        [150] = "https://i.imgur.com/dmN5qFd.png", -- Blob Fish
        [15] = "https://i.imgur.com/i5HPY7d.png",  -- Abyss Seahorse
        [35] = "https://i.imgur.com/oX0y9mk.png",  -- Prismy Seahorse
        [146] = "https://i.imgur.com/lyRcwy2.png", -- Strippled Seahorse
        [47] = "https://i.imgur.com/yDo7zfz.png",  -- Blueflame Ray
        [75] = "https://i.imgur.com/wUQ3ngv.png",  -- Dotted Stingray
        [54] = "https://i.imgur.com/QynhFHm.png",  -- Manta Ray
        [52] = "https://i.imgur.com/Oio2qpc.png",  -- Hammerhead Shark
        [98] = "https://i.imgur.com/0mURszZ.png",  -- Gingerbread Shark
        [122] = "https://i.imgur.com/0mURszZ.png", -- Loving Shark
        [137] = "https://i.imgur.com/umiwlEx.png", -- Plasma Shark
        [147] = "https://i.imgur.com/EWr1i53.png", -- Thresher Shark
        
        -- Uncommon Fish
        [139] = "https://i.imgur.com/0mURszZ.png", -- Silver Tuna
        [186] = "https://i.imgur.com/0mURszZ.png", -- Parrot Fish
        [182] = "https://i.imgur.com/0mURszZ.png", -- Blackcap Basslet
        [140] = "https://i.imgur.com/0mURszZ.png", -- Pilot Fish
    }

    -- Webhook variables
    local webhookURL = ""
    local inventoryWebhookURL = ""
    local isWebhookActive = false
    local isInventoryCheckActive = false
    local lastInventoryState = {}
    local inventoryConnection = nil
    local inventoryCheckConnection = nil
    local httpRetryCount = 0
    local maxHttpRetries = 3
    local inventoryCheckInterval = 180

    -- Fish list for both features
    local fishList = {
        -- Secret Fish
        {name = "Giant Squid", id = 156, tier = "Secret"},
        {name = "Frostborn Shark", id = 136, tier = "Secret"},
        {name = "Great Christmas Whale", id = 99, tier = "Secret"},
        {name = "Great Whale", id = 141, tier = "Secret"},
        {name = "Robot Kraken", id = 159, tier = "Secret"},
        {name = "Worm Fish", id = 145, tier = "Secret"},
        {name = "Ghost Worm Fish", id = 176, tier = "Secret"},
        {name = "Ghost Shark", id = 83, tier = "Secret"},
        {name = "Megalodon", id = 223, tier = "Secret"},
        {name = "Lochaness Monster", id = 228, tier = "Secret"},
        {name = "Scare", id = 225, tier = "Secret"},
        {name = "Thin Armor Shark", id = 218, tier = "Secret"},
        {name = "Monster Shark", id = 206, tier = "Secret"},
        {name = "Crystal Crab", id = 195, tier = "Secret"},
        {name = "Eerie Shark", id = 201, tier = "Secret"},
        {name = "Orca", id = 200, tier = "Secret"},
        {name = "Queen Carb", id = 187, tier = "Secret"},
        
        -- Mythic Fish
        {name = "Lined Cardinal Fish", id = 110, tier = "Mythic"},
        {name = "Gingerbread Turtle", id = 97, tier = "Mythic"},
        {name = "Loggerhead Turtle", id = 34, tier = "Mythic"},
        {name = "Hawks Turtle", id = 21, tier = "Mythic"},
        {name = "Blob Fish", id = 150, tier = "Mythic"},
        {name = "Abyss Seahorse", id = 15, tier = "Mythic"},
        {name = "Prismy Seahorse", id = 35, tier = "Mythic"},
        {name = "Strippled Seahorse", id = 146, tier = "Mythic"},
        {name = "Blueflame Ray", id = 47, tier = "Mythic"},
        {name = "Dotted Stingray", id = 75, tier = "Mythic"},
        {name = "Manta Ray", id = 54, tier = "Mythic"},
        {name = "Hammerhead Shark", id = 52, tier = "Mythic"},
        {name = "Gingerbread Shark", id = 98, tier = "Mythic"},
        {name = "Loving Shark", id = 122, tier = "Mythic"},
        {name = "Plasma Shark", id = 137, tier = "Mythic"},
        {name = "Thresher Shark", id = 147, tier = "Mythic"},
        
        -- Uncommon Fish
        {name = "Silver Tuna", id = 139, tier = "Uncommon"},
        {name = "Parrot Fish", id = 186, tier = "Uncommon"},
        {name = "Blackcap Basslet", id = 182, tier = "Uncommon"},
        {name = "Pilot Fish", id = 140, tier = "Uncommon"}
    }

    local specificFishEnabled = {}
    for _, fish in pairs(fishList) do
        specificFishEnabled[fish.id] = false
    end

    -- Function to get item data from ReplicatedStorage
    local function getItemData(itemId)
        local success, itemData = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local itemsFolder = ReplicatedStorage:FindFirstChild("Items")
            
            if not itemsFolder then
                return nil
            end
            
            for _, itemModule in pairs(itemsFolder:GetChildren()) do
                if itemModule:IsA("ModuleScript") then
                    local success2, data = pcall(function()
                        return require(itemModule)
                    end)
                    
                    if success2 and data and data.Data and data.Data.Id == itemId then
                        return {
                            Id = data.Data.Id,
                            Name = data.Data.Name,
                            Type = data.Data.Type,
                            Tier = data.Data.Tier,
                            SellPrice = data.SellPrice,
                            Weight = data.Weight,
                            Icon = data.Data.Icon,
                            Probability = data.Probability
                        }
                    end
                end
            end
            
            return nil
        end)
        
        if success then
            return itemData
        else
            warn("Error getting item data:", itemData)
            return nil
        end
    end

    -- Cache inventory data from the game's data system
    local function cacheInventoryData()
        local success, error = pcall(function()
            if not var2_upvw then return end
            
            local inventoryData = var2_upvw:Get("Inventory")
            if not inventoryData then return end
            
            cachedInventoryData = {}
            
            for category, items in pairs(inventoryData) do
                if category == "Fishes" then
                    for uuid, itemInfo in pairs(items) do
                        if itemInfo and itemInfo.Id then
                            local itemData = getItemData(itemInfo.Id)
                            if itemData then
                                cachedInventoryData[uuid] = {
                                    id = itemInfo.Id,
                                    name = itemData.Name,
                                    sellPrice = itemData.SellPrice or 0,
                                    weight = itemInfo.Metadata and itemInfo.Metadata.Weight or 0,
                                    quantity = itemInfo.Quantity or 1,
                                    tier = itemData.Tier,
                                    uuid = uuid
                                }
                            end
                        end
                    end
                end
            end
        end)
        
        if not success then
            warn("ERROR: cacheInventoryData failed:", error)
        end
    end

    -- Start monitoring inventory data changes
    local function startInventoryDataMonitoring()
        if inventoryDataConnection then
            inventoryDataConnection:Disconnect()
        end
        
        if var2_upvw then
            inventoryDataConnection = var2_upvw:OnChange("Inventory", function()
                cacheInventoryData()
            end)
            
            cacheInventoryData()
        end
    end

    -- Stop monitoring inventory data
    local function stopInventoryDataMonitoring()
        if inventoryDataConnection then
            inventoryDataConnection:Disconnect()
            inventoryDataConnection = nil
        end
        cachedInventoryData = {}
    end

    -- Create price overlay with centered positioning
    local function createPriceOverlay(fishTile, fishData)        
        if not fishTile or not fishData then
            return
        end
        
        if not fishPriceOverlays then
            fishPriceOverlays = {}
        end
        
        if fishPriceOverlays[fishTile] then
            pcall(function() fishPriceOverlays[fishTile]:Destroy() end)
            fishPriceOverlays[fishTile] = nil
        end

        local priceFrame = Instance.new("Frame")
        priceFrame.Name = "PriceOverlay"
        priceFrame.Size = UDim2.new(1, -10, 0.3, 0)
        priceFrame.Position = UDim2.new(0, 5, 0.35, 0)
        priceFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        priceFrame.BackgroundTransparency = 0.85
        priceFrame.BorderSizePixel = 0
        priceFrame.ZIndex = 200

        local priceLabel = Instance.new("TextLabel")
        priceLabel.Name = "PriceLabel"
        priceLabel.Size = UDim2.new(1, 0, 1, 0)
        priceLabel.Position = UDim2.new(0, 0, 0, 0)
        priceLabel.BackgroundTransparency = 1
        
        local price = tonumber(fishData.sellPrice) or 0
        local formattedPrice = tostring(price):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        priceLabel.Text = formattedPrice .. " coins"
        priceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        priceLabel.TextScaled = true
        priceLabel.Font = Enum.Font.GothamBold
        priceLabel.TextStrokeTransparency = 0.1
        priceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        priceLabel.ZIndex = 201
        priceLabel.Parent = priceFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = priceFrame

        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(40, 40, 40))
        }
        gradient.Rotation = 90
        gradient.Parent = priceFrame

        local border = Instance.new("UIStroke")
        border.Color = Color3.fromRGB(255, 255, 0)
        border.Transparency = 1
        border.Thickness = 1
        border.Parent = priceFrame

        priceFrame.Parent = fishTile
        fishPriceOverlays[fishTile] = priceFrame
    end

    -- Update fish price display
    local function updateFishPriceDisplay()
        local success, error = pcall(function()
            local PlayerGui = game.Players.LocalPlayer.PlayerGui
            local inventoryGui = PlayerGui:FindFirstChild("Inventory")
            
            if not inventoryGui or not inventoryGui.Enabled then
                return
            end
            
            local mainFrame = inventoryGui:FindFirstChild("Main")
            if not mainFrame then return end
            
            local contentFrame = mainFrame:FindFirstChild("Content")
            if not contentFrame then return end
            
            local pagesFrame = contentFrame:FindFirstChild("Pages")
            if not pagesFrame then return end
            
            local inventoryPage = pagesFrame:FindFirstChild("Inventory")
            if not inventoryPage or not inventoryPage.Visible then 
                return 
            end

            if not fishPriceOverlays then
                fishPriceOverlays = {}
            end

            for fishTile, overlay in pairs(fishPriceOverlays) do
                if overlay and overlay.Parent then
                    pcall(function() overlay:Destroy() end)
                end
            end
            fishPriceOverlays = {}

            if not showFishPrices then
                return
            end

            for _, tile in pairs(inventoryPage:GetChildren()) do
                if tile:IsA("ImageButton") and tile.Visible then
                    local fishName = nil
                    
                    local itemNameLabel = tile:FindFirstChild("ItemName", true)
                    if itemNameLabel and itemNameLabel.Text and itemNameLabel.Text ~= "" then
                        fishName = itemNameLabel.Text
                    end
                    
                    if not fishName then
                        local success2, result = pcall(function()
                            for _, child in pairs(tile:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                                    local text = child.Text:lower()
                                    if not string.find(text, "kg") and 
                                       not string.find(text, "coin") and
                                       not string.find(text, "%.") and
                                       string.len(child.Text) > 3 then
                                        return child.Text
                                    end
                                end
                            end
                        end)
                        
                        if success2 and result then
                            fishName = result
                        end
                    end
                    
                    if not fishName and tile.Name and tile.Name ~= "ImageButton" then
                        fishName = tile.Name
                    end
                    
                    if fishName then
                        local fishData = nil
                        
                        if var2_upvw and cachedInventoryData and next(cachedInventoryData) then
                            for uuid, data in pairs(cachedInventoryData) do
                                if data and data.name and 
                                   (data.name == fishName or 
                                    string.find(data.name:lower(), fishName:lower()) or 
                                    string.find(fishName:lower(), data.name:lower())) then
                                    fishData = data
                                    break
                                end
                            end
                        end
                        
                        if not fishData and fishList then
                            for _, fish in pairs(fishList) do
                                if fish and fish.name and fish.id and
                                   (fish.name == fishName or
                                    string.find(fish.name:lower(), fishName:lower()) or 
                                    string.find(fishName:lower(), fish.name:lower())) then
                                    local itemData = getItemData(fish.id)
                                    if itemData and itemData.SellPrice then
                                        fishData = {
                                            name = fish.name,
                                            sellPrice = itemData.SellPrice
                                        }
                                        break
                                    end
                                end
                            end
                        end
                        
                        if not fishData then
                            local success3, result = pcall(function()
                                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                                local itemsFolder = ReplicatedStorage:FindFirstChild("Items")
                                
                                if itemsFolder then
                                    for _, itemModule in pairs(itemsFolder:GetChildren()) do
                                        if itemModule:IsA("ModuleScript") then
                                            local success4, data = pcall(function()
                                                return require(itemModule)
                                            end)
                                            
                                            if success4 and data and data.Data and data.Data.Name then
                                                local itemName = data.Data.Name
                                                if itemName == fishName or
                                                   string.find(itemName:lower(), fishName:lower()) or
                                                   string.find(fishName:lower(), itemName:lower()) then
                                                    
                                                    if data.Data.Type == "Fishes" and data.SellPrice then
                                                        return {
                                                            name = itemName,
                                                            sellPrice = data.SellPrice
                                                        }
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                            
                            if success3 and result then
                                fishData = result
                            end
                        end
                        
                        if not fishData and fishList then
                            local cleanName = fishName:gsub("^Shiny ", ""):gsub("^Big ", ""):gsub("^Giant ", "")
                            cleanName = cleanName:gsub("^Golden ", ""):gsub("^Chrome ", "")
                            
                            for _, fish in pairs(fishList) do
                                if fish and fish.name and fish.id and
                                   (string.find(fish.name:lower(), cleanName:lower()) or
                                    string.find(cleanName:lower(), fish.name:lower())) then
                                    local itemData = getItemData(fish.id)
                                    if itemData and itemData.SellPrice then
                                        fishData = {
                                            name = fish.name,
                                            sellPrice = itemData.SellPrice
                                        }
                                        break
                                    end
                                end
                            end
                        end
                        
                        if fishData then
                            createPriceOverlay(tile, fishData)
                        end
                    end
                end
            end
        end)
        
        if not success then
            warn("ERROR: updateFishPriceDisplay failed:", error)
        end
    end

    -- Start price display monitoring
    local function startPriceDisplayMonitoring()
        startInventoryDataMonitoring()
        
        if priceDisplayConnection then
            priceDisplayConnection:Disconnect()
        end

        priceDisplayConnection = spawn(function()
            while showFishPrices do
                local PlayerGui = game.Players.LocalPlayer.PlayerGui
                local inventoryGui = PlayerGui:FindFirstChild("Inventory")
                
                if inventoryGui and inventoryGui.Enabled then
                    updateFishPriceDisplay()
                end
                
                wait(2)
            end
        end)
        
        local PlayerGui = game.Players.LocalPlayer.PlayerGui
        local inventoryGui = PlayerGui:FindFirstChild("Inventory")
        
        if inventoryGui then
            local inventoryEnabledConnection
            inventoryEnabledConnection = inventoryGui:GetPropertyChangedSignal("Enabled"):Connect(function()
                if inventoryGui.Enabled and showFishPrices then
                    spawn(function()
                        wait(1)
                        updateFishPriceDisplay()
                    end)
                end
            end)
            
            spawn(function()
                while showFishPrices and priceDisplayConnection do
                    wait(1)
                end
                if inventoryEnabledConnection then
                    inventoryEnabledConnection:Disconnect()
                end
            end)
        end
    end

    -- Stop price display monitoring and clean up
    local function stopPriceDisplayMonitoring()
        stopInventoryDataMonitoring()
        
        if priceDisplayConnection then
            pcall(function() priceDisplayConnection:Disconnect() end)
            priceDisplayConnection = nil
        end
        
        if fishPriceOverlays then
            for fishTile, overlay in pairs(fishPriceOverlays) do
                if overlay and overlay.Parent then
                    pcall(function() overlay:Destroy() end)
                end
            end
            fishPriceOverlays = {}
        end
    end

    -- Webhook helper functions
    local function formatWeight(weight, actualWeight)
        if not actualWeight then
            return "Tidak Diketahui"
        end
        
        local weightText = string.format("%.1f kg", actualWeight)
        
        if weight and weight.Big and actualWeight >= weight.Big.Min then
            weightText = weightText .. " (BESAR)"
        end
        
        return weightText
    end

    local function getFishImageURL(fishId)
        local imageUrl = fishImages[fishId]
        if imageUrl and imageUrl ~= "" then
            return imageUrl 
        end
        return nil
    end

    local function getTierInfo(tier)
        local tierColors = {
            [1] = {name = "Common", color = 0x808080},
            [2] = {name = "Uncommon", color = 0x00FF00},
            [3] = {name = "Rare", color = 0x0080FF},
            [4] = {name = "Epic", color = 0x8000FF},
            [5] = {name = "Legendary", color = 0xFF8000},
            [6] = {name = "Mythic", color = 0xFF0080},
            [7] = {name = "Secret", color = 0xFFD700},
            [8] = {name = "Exotic", color = 0xFF69B4}
        }
        return tierColors[tier] or {name = "Unknown", color = 0x808080}
    end

    local function sendWebhook(itemName, itemData, weight, isVariant, variantName)
        if webhookURL == "" then
            return
        end
        local RunService = game:GetService("RunService")
        RunService.Heartbeat:Wait()
        spawn(function()
            local retryAttempt = 0
            local maxRetries = 3
            local success = false
            while retryAttempt < maxRetries and not success do
                retryAttempt = retryAttempt + 1
                local sendSuccess, sendError = pcall(function()
                    local player = game.Players.LocalPlayer
                    local tierInfo = getTierInfo(itemData.Tier or 1)
                    local rarityText = "Tidak Diketahui"
                    if itemData.Probability and itemData.Probability.Chance then
                        local chance = itemData.Probability.Chance
                        rarityText = string.format("1 dari %.0f", 1/chance)
                    end
                    local fullItemName = itemName
                    if isVariant and variantName then
                        fullItemName = variantName .. " " .. itemName
                    end
                    local fishImageURL = getFishImageURL(itemData.Id)
                    local embedData = {
                        ["title"] = " FISH IT - #DJSTEST!",
                       ["color"] = tierInfo.color,
                    ["fields"] = {
                       {
                            ["name"] = "**Profile : **",
                            ["value"] = "> Username :||`"..player.Name.."`||",
                            ["inline"] = true
                        },
                        {
                            ["name"] = "**Fishing : **",
                            ["value"] = "> Fish: `" .. fullItemName.."`\n > Weight: `"..formatWeight(itemData.Weight, weight).."`\n > Price: `".. (itemData.SellPrice or 0) .." Coin`\n > Tier: `"..tierInfo.name .. "`",
                            ["inline"] = false
                        }
                    },
                    ["footer"] = {
                        ["text"] = os.date("%Y-%m-%d %H:%M:%S")
                    }
                }
                    if fishImageURL then
                        embedData["thumbnail"] = {
                            ["url"] = fishImageURL
                        }
                    end
                    local data = {
                        ["username"] = "#DJSTEST",
                        ["embeds"] = {embedData}
                    }
                    local headers = {["Content-Type"] = "application/json"}
                    local body = game:GetService("HttpService"):JSONEncode(data)
                    
                    local req = http_request or request or syn.request
                    if fluxus and fluxus.request then
                        req = fluxus.request
                    end
                    if req then
                        local response = req({
                            Url = webhookURL,
                            Method = "POST",
                            Headers = headers,
                            Body = body
                        })
                        if response and (response.StatusCode == 200 or response.StatusCode == 204) then
                            success = true
                        else
                            error("HTTP Error: " .. (response and response.StatusCode or "Unknown"))
                        end
                    else
                        error("Tidak ada fungsi HTTP request yang tersedia")
                    end
                end)
                if sendSuccess then
                    success = true
                    httpRetryCount = 0
                else
                    warn("Percobaan webhook " .. retryAttempt .. " gagal:", sendError)
                    if retryAttempt < maxRetries then
                        wait(retryAttempt * 2)
                    else
                        httpRetryCount = httpRetryCount + 1
                        
                        if httpRetryCount >= maxHttpRetries then
                            warn("Terlalu banyak kegagalan webhook, menonaktifkan sementara...")
                            isWebhookActive = false
                            spawn(function()
                                wait(30)
                                httpRetryCount = 0
                            end)
                        end
                    end
                end
            end
        end)
    end

    local function sendInventoryWebhook(inventoryData)
        if inventoryWebhookURL == "" then
            warn("Inventory Webhook URL is empty!")
            return
        end
        local RunService = game:GetService("RunService")
        RunService.Heartbeat:Wait()
        spawn(function()
            local retryAttempt = 0
            local maxRetries = 3
            local success = false
            while retryAttempt < maxRetries and not success do
                retryAttempt = retryAttempt + 1
                local sendSuccess, sendError = pcall(function()
                    local player = game.Players.LocalPlayer
                    
                    local playerName = "Unknown"
                    if player and player.Name then
                        playerName = tostring(player.Name)
                    end
                    
                    local fields = {
                        {
                            ["name"] = "**Profile :**",
                            ["value"] = "> Username: ||`" .. playerName .. "`||",
                            ["inline"] = true
                        }
                    }
                    local fishCounts = {}
                    for i, fishInfo in pairs(inventoryData) do
                        local tier = "Unknown"
                        local fishName = "Unknown Fish"
                        
                        if fishInfo then
                            if fishInfo.tierName then
                                tier = tostring(fishInfo.tierName)
                            end
                            if fishInfo.name then
                                fishName = tostring(fishInfo.name)
                            end
                        end
                        if not fishCounts[tier] then
                            fishCounts[tier] = {}
                        end
                        if not fishCounts[tier][fishName] then
                            fishCounts[tier][fishName] = 0
                        end
                        local quantity = 1
                        if fishInfo and fishInfo.quantity then
                            quantity = tonumber(fishInfo.quantity) or 1
                        end
                        
                        fishCounts[tier][fishName] = fishCounts[tier][fishName] + quantity
                    end
                    local fieldCount = 1
                    for tier, fishes in pairs(fishCounts) do
                        if fieldCount >= 25 then
                            break
                        end
                        
                        local fishList = {}
                        local totalInTier = 0
                        
                        for fishName, count in pairs(fishes) do
                            local displayText = "> " .. fishName
                            if count > 1 then
                                displayText = "> " .. fishName .. " x" .. tostring(count)
                            end
                            table.insert(fishList, displayText)
                            totalInTier = totalInTier + count
                        end
                        local fieldValue = "No fish in this tier"
                        if #fishList > 0 then
                            fieldValue = table.concat(fishList, "\n")
                            if string.len(fieldValue) > 1000 then
                                fieldValue = string.sub(fieldValue, 1, 950) .. "...\n> (and more)"
                            end
                        end
                        
                        local fieldName = "**" .. tier .. " Fish (" .. tostring(totalInTier) .. ")**"
                        table.insert(fields, {
                            ["name"] = fieldName,
                            ["value"] = fieldValue,
                            ["inline"] = false
                        })
                        fieldCount = fieldCount + 1
                    end
                    
                    if #inventoryData == 0 then
                        table.insert(fields, {
                            ["name"] = "**Inventory Status :**",
                            ["value"] = "> No fish found in inventory",
                            ["inline"] = false
                        })
                    end
                    
                    local embedData = {
                        ["title"] = "#DJSTEST!",
                        ["color"] = 65535,
                        ["fields"] = fields,
                        ["thumbnail"] = {
                            ["url"] = "https://i.imgur.com/0mURszZ.png"
                        },
                        ["footer"] = {
                            ["text"] = "Total Fish: " .. tostring(#inventoryData) .. " | " .. os.date("%Y-%m-%d %H:%M:%S")
                        }
                    }
                    local data = {
                        ["username"] = "#DJSTEST",
                        ["embeds"] = {embedData}
                    }
                    local headers = {["Content-Type"] = "application/json"}
                    local body = game:GetService("HttpService"):JSONEncode(data)
                    
                    local req = http_request or request or syn.request
                    if fluxus and fluxus.request then
                        req = fluxus.request
                    end
                    if req then
                        local response = req({
                            Url = inventoryWebhookURL,
                            Method = "POST",
                            Headers = headers,
                            Body = body
                        })
                        if response and (response.StatusCode == 200 or response.StatusCode == 204) then
                            success = true
                        else
                            local errorMsg = "HTTP Error: " .. tostring(response.StatusCode or "Unknown")
                            error(errorMsg)
                        end
                    else
                        error("No HTTP request function available")
                    end
                end)
                if sendSuccess then
                    success = true
                    httpRetryCount = 0
                else
                    warn("Webhook attempt " .. retryAttempt .. " failed: " .. tostring(sendError))
                    if retryAttempt < maxRetries then
                        wait(retryAttempt * 2)
                    end
                end
            end
        end)
    end

    local function checkInventoryFish()
        local success, result = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local replionPackage = ReplicatedStorage:FindFirstChild("Packages")
            
            if not replionPackage then
                warn("Packages folder not found")
                return {}
            end
            
            replionPackage = replionPackage:FindFirstChild("_Index")
            if not replionPackage then
                warn("_Index folder not found")
                return {}
            end
            
            local replionModule = nil
            for _, folder in pairs(replionPackage:GetChildren()) do
                if string.find(folder.Name:lower(), "replion") then
                    replionModule = folder:FindFirstChild("replion")
                    if replionModule then
                        break
                    end
                end
            end
            
            if not replionModule then
                warn("Replion module not found")
                return {}
            end
            
            local Replion = require(replionModule)
            local Client = Replion.Client
            local dataReplion = Client:WaitReplion("Data")
            local inventory = dataReplion:Get("Inventory")
            
            if not inventory then
                warn("Inventory data not found")
                return {}
            end
            
            local fishInventory = {}
            
            for category, items in pairs(inventory) do
                if type(items) == "table" then
                    for uuid, itemInfo in pairs(items) do
                        if itemInfo.Id then
                            local itemData = getItemData(itemInfo.Id)
                            if itemData and itemData.Type == "Fishes" then
                                local fishInfo = {
                                    uuid = uuid,
                                    id = itemInfo.Id,
                                    name = itemData.Name,
                                    tier = itemData.Tier,
                                    tierName = getTierInfo(itemData.Tier).name,
                                    sellPrice = itemData.SellPrice or 0,
                                    quantity = itemInfo.Quantity
                                }
                                
                                if itemInfo.Metadata and itemInfo.Metadata.VariantId then
                                    local variantSuccess, variantData = pcall(function()
                                        local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
                                        return ItemUtility:GetVariantData(itemInfo.Metadata.VariantId)
                                    end)
                                    
                                    if variantSuccess and variantData and variantData.Data then
                                        fishInfo.variant = variantData.Data.Name
                                        fishInfo.name = variantData.Data.Name .. " " .. fishInfo.name
                                    end
                                end
                                
                                table.insert(fishInventory, fishInfo)
                            end
                        end
                    end
                end
            end
            
            return fishInventory
        end)
        
        if success then
            return result
        else
            warn("Error checking inventory:", result)
            return {}
        end
    end

    local function startReplionMonitoring()
        local success, error = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local replionPackage = ReplicatedStorage:FindFirstChild("Packages")
            if replionPackage then
                replionPackage = replionPackage:FindFirstChild("_Index")
                if replionPackage then
                    for _, folder in pairs(replionPackage:GetChildren()) do
                        if string.find(folder.Name:lower(), "replion") then
                            local replionModule = folder:FindFirstChild("replion")
                            if replionModule then
                                local Replion = require(replionModule)
                                local Client = Replion.Client
                                local dataReplion = Client:WaitReplion("Data")
                                local lastProcessTime = 0
                                local processingCooldown = 2
                                dataReplion:OnChange("Inventory", function(newInventory, oldInventory)
                                    if not isWebhookActive or not newInventory then
                                        return
                                    end
                                    local currentTime = tick()
                                    if currentTime - lastProcessTime < processingCooldown then
                                        return
                                    end
                                    lastProcessTime = currentTime
                                    task.defer(function()
                                        local processSuccess, processError = pcall(function()
                                            for category, items in pairs(newInventory) do
                                                if type(items) == "table" then
                                                    for uuid, itemInfo in pairs(items) do
                                                        local isNewItem = false
                                                        if not oldInventory or not oldInventory[category] or not oldInventory[category][uuid] then
                                                            isNewItem = true
                                                        elseif oldInventory[category][uuid].Quantity and itemInfo.Quantity then
                                                            if itemInfo.Quantity > oldInventory[category][uuid].Quantity then
                                                                isNewItem = true
                                                            end
                                                        end
                                                        if isNewItem and itemInfo.Id then
                                                            local itemData = getItemData(itemInfo.Id)
                                                            if itemData and itemData.Type == "Fishes" then
                                                                local fishId = itemInfo.Id
                                                                if specificFishEnabled[fishId] == true then
                                                                    local isVariant = false
                                                                    local variantName = nil
                                                                    if itemInfo.Metadata and itemInfo.Metadata.VariantId then
                                                                        local variantSuccess, variantData = pcall(function()
                                                                            local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
                                                                            return ItemUtility:GetVariantData(itemInfo.Metadata.VariantId)
                                                                        end)
                                                                        
                                                                        if variantSuccess and variantData and variantData.Data then
                                                                            isVariant = true
                                                                            variantName = variantData.Data.Name
                                                                        end
                                                                    end
                                                                    
                                                                    local weight = nil
                                                                    if itemInfo.Metadata and itemInfo.Metadata.Weight then
                                                                        weight = itemInfo.Metadata.Weight
                                                                    end
                                                                    sendWebhook(itemData.Name, itemData, weight, isVariant, variantName)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end)
                                        if not processSuccess then
                                            warn("Error memproses perubahan inventory:", processError)
                                        end
                                    end)
                                end)
                                return true
                            end
                        end
                    end
                end
            end
            return false
        end)
        if success then
            return true
        else
            warn("Gagal memulai monitoring Replion:", error)
            return false
        end
    end

    local function startInventoryCheckTimer()
        if inventoryCheckConnection then
            inventoryCheckConnection:Disconnect()
        end
        
        inventoryCheckConnection = spawn(function()
            while isInventoryCheckActive do
                wait(inventoryCheckInterval)
                if isInventoryCheckActive then
                    local fishInventory = checkInventoryFish()
                    if #fishInventory > 0 then
                        sendInventoryWebhook(fishInventory)
                    else
                        sendInventoryWebhook({})
                    end
                end
            end
        end)
    end

    local function stopInventoryCheckTimer()
        if inventoryCheckConnection then
            inventoryCheckConnection:Disconnect()
            inventoryCheckConnection = nil
        end
    end

    local function startInventoryMonitoring()
        httpRetryCount = 0
        if startReplionMonitoring() then
            return
        end
        if inventoryConnection then
            inventoryConnection:Disconnect()
        end
    end

    local function stopInventoryMonitoring()
        if inventoryConnection then
            inventoryConnection:Disconnect()
            inventoryConnection = nil
        end
        lastInventoryState = {}
        httpRetryCount = 0
    end

    -- UI Components
    local WebhookInput = WebhookTab:AddInput("Input", {
        Title = "Fishing Webhook URL",
        Description = "",
        Default = "",
        Placeholder = "nothing...",
        Numeric = false,
        Finished = false,
        Callback = function(Text)
            webhookURL = Text
            httpRetryCount = 0
        end
    })

    local InventoryWebhookInput = WebhookTab:AddInput("InventoryInput", {
        Title = "Inventory Webhook URL",
        Description = "",
        Default = "",
        Placeholder = "nothing...",
        Numeric = false,
        Finished = false,
        Callback = function(Text)
            inventoryWebhookURL = Text
            httpRetryCount = 0
        end
    })

    local FishDropdown = WebhookTab:AddDropdown("FishSelection", {
        Title = "Select Fish",
        Description = "",
        Values = {"Secret", "Mythic", "Uncommon"},
        Multi = true,
        Default = {},
    })

    FishDropdown:OnChanged(function(selectedTiers)
        for fishId, _ in pairs(specificFishEnabled) do
            specificFishEnabled[fishId] = false
        end
        for tierName, isSelected in pairs(selectedTiers) do
            if isSelected then
                for _, fish in pairs(fishList) do
                    if fish.tier == tierName then
                        specificFishEnabled[fish.id] = true
                    end
                end
            end
        end
    end)

    local WebhookToggle = WebhookTab:AddToggle("webhooktracking", {
        Title = "Enable Fishing Webhook", 
        Description = "Toggle for fishing webhook notifications",
        Default = false,
        Callback = function(Value)
            isWebhookActive = Value
            
            if Value then
                if webhookURL == "" then
                    Options.webhooktracking:SetValue(false)
                    warn("Please set Fishing Webhook URL first!")
                    wait(5)
                    Options.webhooktracking:SetValue(true)
                    return
                end
                startInventoryMonitoring()
            else
                stopInventoryMonitoring()
            end
        end 
    })

    local InventoryCheckToggle = WebhookTab:AddToggle("inventorycheck", {
        Title = "Enable Inventory Webhook", 
        Description = "Automatically send inventory check every 3 minutes",
        Default = false,
        Callback = function(Value)
            isInventoryCheckActive = Value
            
            if Value then
                if inventoryWebhookURL == "" then
                    Options.inventorycheck:SetValue(false)
                    warn("Please set Inventory Webhook URL first!")
                    wait(5)
                    Options.inventorycheck:SetValue(true)
                    return
                end
                startInventoryCheckTimer()
            else
                stopInventoryCheckTimer()
            end
        end 
    })

    WebhookTab:AddButton({
        Title = "Clear Select",
        Description = "",
        Callback = function()
            FishDropdown:SetValue({})
        end
    })

    WebhookTab:AddButton({
        Title = "Test Webhook",
        Description = "",
        Callback = function()
            if webhookURL == "" then
                return
            end
            local testData = {
                Id = 159,
                Name = "Robot Kraken",
                Type = "Fishes",
                Tier = 7,
                SellPrice = 387500,
                Weight = {Default = {Min = 419600, Max = 486470}},
                Probability = {Chance = 0.05}
            }
            sendWebhook("TEST Robot Kraken", testData, 419600, false, nil)
        end
    })

    -- Initialize the system when var2_upvw becomes available
    spawn(function()
        while not var2_upvw do
            wait(1)
        end
        
        if showFishPrices then
            stopPriceDisplayMonitoring()
            startPriceDisplayMonitoring()
        end
    end)
end
do
local isAutoGiveActive = false
local autoTradeConnection = nil
local hookApplied = false
local originalCreateTradePrompt = nil

local function setupAutoGive()
    local success, error = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
        if Controllers then
            local ItemTradingController = Controllers:FindFirstChild("ItemTradingController")
            if ItemTradingController then
                local controller = require(ItemTradingController)
                
                -- Store original function if not already stored
                if not originalCreateTradePrompt and controller.CreateTradePrompt then
                    originalCreateTradePrompt = controller.CreateTradePrompt
                    print("[AUTO GIVE] Original CreateTradePrompt function stored")
                end
                
                -- Hook the CreateTradePrompt function for outgoing trades only
                controller.CreateTradePrompt = function(self, itemData, itemInfo, tradeInfo)
                    print("[AUTO GIVE] CreateTradePrompt called:")
                    print("  itemData:", itemData)
                    print("  itemInfo:", itemInfo) 
                    print("  tradeInfo:", tradeInfo)
                    
                    -- Auto accept outgoing trades (giving items) only
                    if isAutoGiveActive and tradeInfo and tradeInfo.target then
                        local Promise = require(ReplicatedStorage.Packages.Promise)
                        print("[AUTO GIVE] Auto giving item to:", tradeInfo.target.DisplayName)
                        
                        task.spawn(function()
                            task.wait(0.2)
                            print("[AUTO GIVE] Returning true for outgoing trade")
                        end)
                        
                        return Promise.resolve(true)
                    end
                    
                    -- For all other cases (including incoming trades), use original function
                    if originalCreateTradePrompt then
                        print("[AUTO GIVE] Calling original CreateTradePrompt (not auto-giving)")
                        return originalCreateTradePrompt(self, itemData, itemInfo, tradeInfo)
                    else
                        local Promise = require(ReplicatedStorage.Packages.Promise)
                        warn("[AUTO GIVE] Original function not found")
                        return Promise.reject("Original function not found")
                    end
                end
                
                hookApplied = true
                
                -- Maintain the hook with RunService connection
                if autoTradeConnection then
                    autoTradeConnection:Disconnect()
                end
                
                autoTradeConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    -- Check every 3 seconds to maintain hook
                    if math.floor(tick()) % 3 == 0 and tick() % 1 < 0.1 then
                        local currentController = require(ItemTradingController)
                        if currentController.CreateTradePrompt ~= controller.CreateTradePrompt then
                            print("[AUTO GIVE] Re-applying CreateTradePrompt hook")
                            currentController.CreateTradePrompt = controller.CreateTradePrompt
                        end
                    end
                end)
                
                print("[AUTO GIVE] Hook successfully applied!")
                return true
            else
                warn("[AUTO GIVE] ItemTradingController not found!")
            end
        else
            warn("[AUTO GIVE] Controllers folder not found!")
        end
        
        return false
    end)
    
    if not success then
        warn("[AUTO GIVE] Setup error:", tostring(error))
        return false
    end
    return success
end

local function disableAutoGive()
    local success, error = pcall(function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Controllers = ReplicatedStorage:FindFirstChild("Controllers")
        
        if Controllers then
            local ItemTradingController = Controllers:FindFirstChild("ItemTradingController")
            if ItemTradingController then
                local controller = require(ItemTradingController)
                if originalCreateTradePrompt then
                    print("[AUTO GIVE] Restoring original CreateTradePrompt function")
                    controller.CreateTradePrompt = originalCreateTradePrompt
                end
            end
        end
        
        if autoTradeConnection then
            autoTradeConnection:Disconnect()
            autoTradeConnection = nil
        end
        
        hookApplied = false
        print("[AUTO GIVE] Hook disabled!")
        return true
    end)
    
    if not success then
        warn("[AUTO GIVE] Disable error:", tostring(error))
        return false
    end
    return success
end
local autoGiveToggle = Tabs.Inventory:AddToggle("AutoGive", {
    Title = "Skip Prompt Give",
    Description = "Automatically give items when trading",
    Default = false,
    Callback = function(Value)
        if Value then
            if not isAutoGiveActive then
                local success = setupAutoGive()
                if success then
                    isAutoGiveActive = true
                else
                    Options.AutoGive:SetValue(false)
                end
            end
        else
            if isAutoGiveActive then
                isAutoGiveActive = false
                disableAutoGive()
            end
        end
    end
})
local FishPriceToggle = Tabs.Inventory:AddToggle("showfishprices", {
    Title = "Show Fish Prices",
    Description = "Display fish sell prices on inventory tiles",
    Default = false,
    Callback = function(Value)
        showFishPrices = Value
        
        if Value then
            startPriceDisplayMonitoring()
        else
            stopPriceDisplayMonitoring()
        end
    end 
})

end
Window:SelectTab(1)
AutoConfig:Initialize(Fluent)
end
